"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

exports.__esModule = true;
exports.default = uncontrollable;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _react = _interopRequireDefault(require("react"));

var _reactLifecyclesCompat = require("react-lifecycles-compat");

var _invariant = _interopRequireDefault(require("invariant"));

var Utils = _interopRequireWildcard(require("./utils"));

var _jsxFileName = "/Users/jquense/src/uncontrollable/src/uncontrollable.js";

function uncontrollable(Component, controlledValues, methods) {
  if (methods === void 0) {
    methods = [];
  }

  let displayName = Component.displayName || Component.name || 'Component';
  let canAcceptRef = Utils.canAcceptRef(Component);
  let controlledProps = Object.keys(controlledValues);
  const PROPS_TO_OMIT = controlledProps.map(Utils.defaultKey);
  !(canAcceptRef || !methods.length) ? process.env.NODE_ENV !== "production" ? (0, _invariant.default)(false, '[uncontrollable] stateless function components cannot pass through methods ' + 'because they have no associated instances. Check component: ' + displayName + ', ' + 'attempting to pass through methods: ' + methods.join(', ')) : invariant(false) : void 0;

  class UncontrolledComponent extends _react.default.Component {
    constructor() {
      var _this;

      super(...arguments);
      _this = this;
      this.handlers = Object.create(null);
      controlledProps.forEach(propName => {
        const handlerName = controlledValues[propName];

        const handleChange = function handleChange(value) {
          if (_this.props[handlerName]) {
            _this._notifying = true;

            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }

            _this.props[handlerName](value, ...args);

            _this._notifying = false;
          }

          if (!_this.unmounted) _this.setState((_ref) => {
            let values = _ref.values;
            return {
              values: (0, _extends2.default)(Object.create(null), values, {
                [propName]: value
              })
            };
          });
        };

        this.handlers[handlerName] = handleChange;
      });
      if (methods.length) this.attachRef = ref => {
        this.inner = ref;
      };
      const values = Object.create(null);
      controlledProps.forEach(key => {
        values[key] = this.props[Utils.defaultKey(key)];
      });
      this.state = {
        values,
        prevProps: {}
      };
    }

    shouldComponentUpdate() {
      //let setState trigger the update
      return !this._notifying;
    }

    static getDerivedStateFromProps(props, _ref2) {
      let values = _ref2.values,
          prevProps = _ref2.prevProps;
      const nextState = {
        values: (0, _extends2.default)(Object.create(null), values),
        prevProps: {}
      };
      controlledProps.forEach(key => {
        /**
         * If a prop switches from controlled to Uncontrolled
         * reset its value to the defaultValue
         */
        nextState.prevProps[key] = props[key];

        if (!Utils.isProp(props, key) && Utils.isProp(prevProps, key)) {
          nextState.values[key] = props[Utils.defaultKey(key)];
        }
      });
      return nextState;
    }

    componentWillUnmount() {
      this.unmounted = true;
    }

    render() {
      let _this$props = this.props,
          innerRef = _this$props.innerRef,
          props = (0, _objectWithoutPropertiesLoose2.default)(_this$props, ["innerRef"]);
      PROPS_TO_OMIT.forEach(prop => {
        delete props[prop];
      });
      let newProps = {};
      controlledProps.forEach(propName => {
        let propValue = this.props[propName];
        newProps[propName] = propValue !== undefined ? propValue : this.state.values[propName];
      });
      return _react.default.createElement(Component, (0, _extends2.default)({}, props, newProps, this.handlers, {
        ref: innerRef || this.attachRef
      }));
    }

  }

  (0, _reactLifecyclesCompat.polyfill)(UncontrolledComponent);
  UncontrolledComponent.displayName = `Uncontrolled(${displayName})`;
  UncontrolledComponent.propTypes = (0, _extends2.default)({
    innerRef: () => {}
  }, Utils.uncontrolledPropTypes(controlledValues, displayName));
  methods.forEach(method => {
    UncontrolledComponent.prototype[method] = function $proxiedMethod() {
      return this.inner[method](...arguments);
    };
  });
  let WrappedComponent = UncontrolledComponent;

  if (_react.default.forwardRef) {
    WrappedComponent = _react.default.forwardRef((props, ref) => _react.default.createElement(UncontrolledComponent, (0, _extends2.default)({}, props, {
      innerRef: ref,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 128
      },
      __self: this
    })));
    WrappedComponent.propTypes = UncontrolledComponent.propTypes;
  }

  WrappedComponent.ControlledComponent = Component;
  /**
   * useful when wrapping a Component and you want to control
   * everything
   */

  WrappedComponent.deferControlTo = function (newComponent, additions, nextMethods) {
    if (additions === void 0) {
      additions = {};
    }

    return uncontrollable(newComponent, (0, _extends2.default)({}, controlledValues, additions), nextMethods);
  };

  return WrappedComponent;
}

module.exports = exports["default"];