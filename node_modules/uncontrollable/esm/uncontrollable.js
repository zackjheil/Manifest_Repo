import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import _extends from "@babel/runtime/helpers/esm/extends";
var _jsxFileName = "/Users/jquense/src/uncontrollable/src/uncontrollable.js";
import React from 'react';
import { polyfill } from 'react-lifecycles-compat';
import invariant from 'invariant';
import * as Utils from './utils';
export default function uncontrollable(Component, controlledValues, methods) {
  if (methods === void 0) {
    methods = [];
  }

  let displayName = Component.displayName || Component.name || 'Component';
  let canAcceptRef = Utils.canAcceptRef(Component);
  let controlledProps = Object.keys(controlledValues);
  const PROPS_TO_OMIT = controlledProps.map(Utils.defaultKey);
  !(canAcceptRef || !methods.length) ? process.env.NODE_ENV !== "production" ? invariant(false, '[uncontrollable] stateless function components cannot pass through methods ' + 'because they have no associated instances. Check component: ' + displayName + ', ' + 'attempting to pass through methods: ' + methods.join(', ')) : invariant(false) : void 0;

  class UncontrolledComponent extends React.Component {
    constructor() {
      var _this;

      super(...arguments);
      _this = this;
      this.handlers = Object.create(null);
      controlledProps.forEach(propName => {
        const handlerName = controlledValues[propName];

        const handleChange = function handleChange(value) {
          if (_this.props[handlerName]) {
            _this._notifying = true;

            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }

            _this.props[handlerName](value, ...args);

            _this._notifying = false;
          }

          if (!_this.unmounted) _this.setState((_ref) => {
            let values = _ref.values;
            return {
              values: _extends(Object.create(null), values, {
                [propName]: value
              })
            };
          });
        };

        this.handlers[handlerName] = handleChange;
      });
      if (methods.length) this.attachRef = ref => {
        this.inner = ref;
      };
      const values = Object.create(null);
      controlledProps.forEach(key => {
        values[key] = this.props[Utils.defaultKey(key)];
      });
      this.state = {
        values,
        prevProps: {}
      };
    }

    shouldComponentUpdate() {
      //let setState trigger the update
      return !this._notifying;
    }

    static getDerivedStateFromProps(props, _ref2) {
      let values = _ref2.values,
          prevProps = _ref2.prevProps;
      const nextState = {
        values: _extends(Object.create(null), values),
        prevProps: {}
      };
      controlledProps.forEach(key => {
        /**
         * If a prop switches from controlled to Uncontrolled
         * reset its value to the defaultValue
         */
        nextState.prevProps[key] = props[key];

        if (!Utils.isProp(props, key) && Utils.isProp(prevProps, key)) {
          nextState.values[key] = props[Utils.defaultKey(key)];
        }
      });
      return nextState;
    }

    componentWillUnmount() {
      this.unmounted = true;
    }

    render() {
      let _this$props = this.props,
          innerRef = _this$props.innerRef,
          props = _objectWithoutPropertiesLoose(_this$props, ["innerRef"]);

      PROPS_TO_OMIT.forEach(prop => {
        delete props[prop];
      });
      let newProps = {};
      controlledProps.forEach(propName => {
        let propValue = this.props[propName];
        newProps[propName] = propValue !== undefined ? propValue : this.state.values[propName];
      });
      return React.createElement(Component, _extends({}, props, newProps, this.handlers, {
        ref: innerRef || this.attachRef
      }));
    }

  }

  polyfill(UncontrolledComponent);
  UncontrolledComponent.displayName = `Uncontrolled(${displayName})`;
  UncontrolledComponent.propTypes = _extends({
    innerRef: () => {}
  }, Utils.uncontrolledPropTypes(controlledValues, displayName));
  methods.forEach(method => {
    UncontrolledComponent.prototype[method] = function $proxiedMethod() {
      return this.inner[method](...arguments);
    };
  });
  let WrappedComponent = UncontrolledComponent;

  if (React.forwardRef) {
    WrappedComponent = React.forwardRef((props, ref) => React.createElement(UncontrolledComponent, _extends({}, props, {
      innerRef: ref,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 128
      },
      __self: this
    })));
    WrappedComponent.propTypes = UncontrolledComponent.propTypes;
  }

  WrappedComponent.ControlledComponent = Component;
  /**
   * useful when wrapping a Component and you want to control
   * everything
   */

  WrappedComponent.deferControlTo = function (newComponent, additions, nextMethods) {
    if (additions === void 0) {
      additions = {};
    }

    return uncontrollable(newComponent, _extends({}, controlledValues, additions), nextMethods);
  };

  return WrappedComponent;
}