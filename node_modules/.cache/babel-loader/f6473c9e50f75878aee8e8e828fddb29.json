{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _createForOfIteratorHelper from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\nimport { assert } from './assert.js';\nimport { executeQuotaErrorCallbacks } from './executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from './getFriendlyURL.js';\nimport { logger } from './logger.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport { WorkboxError } from './WorkboxError.js';\nimport '../_version.js';\n/**\r\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\r\n * executes any of those callbacks found in sequence. The final `Request` object\r\n * returned by the last plugin is treated as the cache key for cache reads\r\n * and/or writes.\r\n *\r\n * @param {Object} options\r\n * @param {Request} options.request\r\n * @param {string} options.mode\r\n * @param {Array<Object>} [options.plugins=[]]\r\n * @return {Promise<Request>}\r\n *\r\n * @private\r\n * @memberof module:workbox-core\r\n */\n\nvar _getEffectiveRequest = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n    var request, mode, _ref$plugins, plugins, cacheKeyWillBeUsedPlugins, effectiveRequest, _iterator, _step, plugin;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            request = _ref.request, mode = _ref.mode, _ref$plugins = _ref.plugins, plugins = _ref$plugins === void 0 ? [] : _ref$plugins;\n            cacheKeyWillBeUsedPlugins = pluginUtils.filter(plugins, \"cacheKeyWillBeUsed\"\n            /* CACHE_KEY_WILL_BE_USED */\n            );\n            effectiveRequest = request;\n            _iterator = _createForOfIteratorHelper(cacheKeyWillBeUsedPlugins);\n            _context.prev = 4;\n\n            _iterator.s();\n\n          case 6:\n            if ((_step = _iterator.n()).done) {\n              _context.next = 15;\n              break;\n            }\n\n            plugin = _step.value;\n            _context.next = 10;\n            return plugin[\"cacheKeyWillBeUsed\"\n            /* CACHE_KEY_WILL_BE_USED */\n            ].call(plugin, {\n              mode: mode,\n              request: effectiveRequest\n            });\n\n          case 10:\n            effectiveRequest = _context.sent;\n\n            if (typeof effectiveRequest === 'string') {\n              effectiveRequest = new Request(effectiveRequest);\n            }\n\n            if (process.env.NODE_ENV !== 'production') {\n              assert.isInstance(effectiveRequest, Request, {\n                moduleName: 'Plugin',\n                funcName: \"cacheKeyWillBeUsed\"\n                /* CACHE_KEY_WILL_BE_USED */\n                ,\n                isReturnValueProblem: true\n              });\n            }\n\n          case 13:\n            _context.next = 6;\n            break;\n\n          case 15:\n            _context.next = 20;\n            break;\n\n          case 17:\n            _context.prev = 17;\n            _context.t0 = _context[\"catch\"](4);\n\n            _iterator.e(_context.t0);\n\n          case 20:\n            _context.prev = 20;\n\n            _iterator.f();\n\n            return _context.finish(20);\n\n          case 23:\n            return _context.abrupt(\"return\", effectiveRequest);\n\n          case 24:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[4, 17, 20, 23]]);\n  }));\n\n  return function _getEffectiveRequest(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\r\n * This method will call cacheWillUpdate on the available plugins (or use\r\n * status === 200) to determine if the Response is safe and valid to cache.\r\n *\r\n * @param {Object} options\r\n * @param {Request} options.request\r\n * @param {Response} options.response\r\n * @param {Event} [options.event]\r\n * @param {Array<Object>} [options.plugins=[]]\r\n * @return {Promise<Response>}\r\n *\r\n * @private\r\n * @memberof module:workbox-core\r\n */\n\n\nvar _isResponseSafeToCache = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3) {\n    var request, response, event, _ref3$plugins, plugins, responseToCache, pluginsUsed, _iterator2, _step2, plugin, pluginMethod;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            request = _ref3.request, response = _ref3.response, event = _ref3.event, _ref3$plugins = _ref3.plugins, plugins = _ref3$plugins === void 0 ? [] : _ref3$plugins;\n            responseToCache = response;\n            pluginsUsed = false;\n            _iterator2 = _createForOfIteratorHelper(plugins);\n            _context2.prev = 4;\n\n            _iterator2.s();\n\n          case 6:\n            if ((_step2 = _iterator2.n()).done) {\n              _context2.next = 19;\n              break;\n            }\n\n            plugin = _step2.value;\n\n            if (!(\"cacheWillUpdate\"\n            /* CACHE_WILL_UPDATE */\n            in plugin)) {\n              _context2.next = 17;\n              break;\n            }\n\n            pluginsUsed = true;\n            pluginMethod = plugin[\"cacheWillUpdate\"\n            /* CACHE_WILL_UPDATE */\n            ];\n            _context2.next = 13;\n            return pluginMethod.call(plugin, {\n              request: request,\n              response: responseToCache,\n              event: event\n            });\n\n          case 13:\n            responseToCache = _context2.sent;\n\n            if (process.env.NODE_ENV !== 'production') {\n              if (responseToCache) {\n                assert.isInstance(responseToCache, Response, {\n                  moduleName: 'Plugin',\n                  funcName: \"cacheWillUpdate\"\n                  /* CACHE_WILL_UPDATE */\n                  ,\n                  isReturnValueProblem: true\n                });\n              }\n            }\n\n            if (responseToCache) {\n              _context2.next = 17;\n              break;\n            }\n\n            return _context2.abrupt(\"break\", 19);\n\n          case 17:\n            _context2.next = 6;\n            break;\n\n          case 19:\n            _context2.next = 24;\n            break;\n\n          case 21:\n            _context2.prev = 21;\n            _context2.t0 = _context2[\"catch\"](4);\n\n            _iterator2.e(_context2.t0);\n\n          case 24:\n            _context2.prev = 24;\n\n            _iterator2.f();\n\n            return _context2.finish(24);\n\n          case 27:\n            if (!pluginsUsed) {\n              if (process.env.NODE_ENV !== 'production') {\n                if (responseToCache) {\n                  if (responseToCache.status !== 200) {\n                    if (responseToCache.status === 0) {\n                      logger.warn(\"The response for '\".concat(request.url, \"' is an opaque \") + \"response. The caching strategy that you're using will not \" + \"cache opaque responses by default.\");\n                    } else {\n                      logger.debug(\"The response for '\".concat(request.url, \"' returned \") + \"a status code of '\".concat(response.status, \"' and won't be cached as a \") + \"result.\");\n                    }\n                  }\n                }\n              }\n\n              responseToCache = responseToCache && responseToCache.status === 200 ? responseToCache : undefined;\n            }\n\n            return _context2.abrupt(\"return\", responseToCache ? responseToCache : null);\n\n          case 29:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[4, 21, 24, 27]]);\n  }));\n\n  return function _isResponseSafeToCache(_x2) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n/**\r\n * This is a wrapper around cache.match().\r\n *\r\n * @param {Object} options\r\n * @param {string} options.cacheName Name of the cache to match against.\r\n * @param {Request} options.request The Request that will be used to look up\r\n *     cache entries.\r\n * @param {Event} [options.event] The event that prompted the action.\r\n * @param {Object} [options.matchOptions] Options passed to cache.match().\r\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\r\n * @return {Response} A cached response if available.\r\n *\r\n * @private\r\n * @memberof module:workbox-core\r\n */\n\n\nvar matchWrapper = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref5) {\n    var cacheName, request, event, matchOptions, _ref5$plugins, plugins, cache, effectiveRequest, cachedResponse, _iterator3, _step3, plugin, pluginMethod;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            cacheName = _ref5.cacheName, request = _ref5.request, event = _ref5.event, matchOptions = _ref5.matchOptions, _ref5$plugins = _ref5.plugins, plugins = _ref5$plugins === void 0 ? [] : _ref5$plugins;\n            _context3.next = 3;\n            return self.caches.open(cacheName);\n\n          case 3:\n            cache = _context3.sent;\n            _context3.next = 6;\n            return _getEffectiveRequest({\n              plugins: plugins,\n              request: request,\n              mode: 'read'\n            });\n\n          case 6:\n            effectiveRequest = _context3.sent;\n            _context3.next = 9;\n            return cache.match(effectiveRequest, matchOptions);\n\n          case 9:\n            cachedResponse = _context3.sent;\n\n            if (process.env.NODE_ENV !== 'production') {\n              if (cachedResponse) {\n                logger.debug(\"Found a cached response in '\".concat(cacheName, \"'.\"));\n              } else {\n                logger.debug(\"No cached response found in '\".concat(cacheName, \"'.\"));\n              }\n            }\n\n            _iterator3 = _createForOfIteratorHelper(plugins);\n            _context3.prev = 12;\n\n            _iterator3.s();\n\n          case 14:\n            if ((_step3 = _iterator3.n()).done) {\n              _context3.next = 24;\n              break;\n            }\n\n            plugin = _step3.value;\n\n            if (!(\"cachedResponseWillBeUsed\"\n            /* CACHED_RESPONSE_WILL_BE_USED */\n            in plugin)) {\n              _context3.next = 22;\n              break;\n            }\n\n            pluginMethod = plugin[\"cachedResponseWillBeUsed\"\n            /* CACHED_RESPONSE_WILL_BE_USED */\n            ];\n            _context3.next = 20;\n            return pluginMethod.call(plugin, {\n              cacheName: cacheName,\n              event: event,\n              matchOptions: matchOptions,\n              cachedResponse: cachedResponse,\n              request: effectiveRequest\n            });\n\n          case 20:\n            cachedResponse = _context3.sent;\n\n            if (process.env.NODE_ENV !== 'production') {\n              if (cachedResponse) {\n                assert.isInstance(cachedResponse, Response, {\n                  moduleName: 'Plugin',\n                  funcName: \"cachedResponseWillBeUsed\"\n                  /* CACHED_RESPONSE_WILL_BE_USED */\n                  ,\n                  isReturnValueProblem: true\n                });\n              }\n            }\n\n          case 22:\n            _context3.next = 14;\n            break;\n\n          case 24:\n            _context3.next = 29;\n            break;\n\n          case 26:\n            _context3.prev = 26;\n            _context3.t0 = _context3[\"catch\"](12);\n\n            _iterator3.e(_context3.t0);\n\n          case 29:\n            _context3.prev = 29;\n\n            _iterator3.f();\n\n            return _context3.finish(29);\n\n          case 32:\n            return _context3.abrupt(\"return\", cachedResponse);\n\n          case 33:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[12, 26, 29, 32]]);\n  }));\n\n  return function matchWrapper(_x3) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n/**\r\n * Wrapper around cache.put().\r\n *\r\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\r\n * `matchOptions` when determining what the old entry is.\r\n *\r\n * @param {Object} options\r\n * @param {string} options.cacheName\r\n * @param {Request} options.request\r\n * @param {Response} options.response\r\n * @param {Event} [options.event]\r\n * @param {Array<Object>} [options.plugins=[]]\r\n * @param {Object} [options.matchOptions]\r\n *\r\n * @private\r\n * @memberof module:workbox-core\r\n */\n\n\nvar putWrapper = /*#__PURE__*/function () {\n  var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref7) {\n    var cacheName, request, response, event, _ref7$plugins, plugins, matchOptions, effectiveRequest, responseToCache, cache, updatePlugins, oldResponse, _iterator4, _step4, plugin;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            cacheName = _ref7.cacheName, request = _ref7.request, response = _ref7.response, event = _ref7.event, _ref7$plugins = _ref7.plugins, plugins = _ref7$plugins === void 0 ? [] : _ref7$plugins, matchOptions = _ref7.matchOptions;\n\n            if (!(process.env.NODE_ENV !== 'production')) {\n              _context4.next = 4;\n              break;\n            }\n\n            if (!(request.method && request.method !== 'GET')) {\n              _context4.next = 4;\n              break;\n            }\n\n            throw new WorkboxError('attempt-to-cache-non-get-request', {\n              url: getFriendlyURL(request.url),\n              method: request.method\n            });\n\n          case 4:\n            _context4.next = 6;\n            return _getEffectiveRequest({\n              plugins: plugins,\n              request: request,\n              mode: 'write'\n            });\n\n          case 6:\n            effectiveRequest = _context4.sent;\n\n            if (response) {\n              _context4.next = 10;\n              break;\n            }\n\n            if (process.env.NODE_ENV !== 'production') {\n              logger.error(\"Cannot cache non-existent response for \" + \"'\".concat(getFriendlyURL(effectiveRequest.url), \"'.\"));\n            }\n\n            throw new WorkboxError('cache-put-with-no-response', {\n              url: getFriendlyURL(effectiveRequest.url)\n            });\n\n          case 10:\n            _context4.next = 12;\n            return _isResponseSafeToCache({\n              event: event,\n              plugins: plugins,\n              response: response,\n              request: effectiveRequest\n            });\n\n          case 12:\n            responseToCache = _context4.sent;\n\n            if (responseToCache) {\n              _context4.next = 16;\n              break;\n            }\n\n            if (process.env.NODE_ENV !== 'production') {\n              logger.debug(\"Response '\".concat(getFriendlyURL(effectiveRequest.url), \"' will \") + \"not be cached.\", responseToCache);\n            }\n\n            return _context4.abrupt(\"return\");\n\n          case 16:\n            _context4.next = 18;\n            return self.caches.open(cacheName);\n\n          case 18:\n            cache = _context4.sent;\n            updatePlugins = pluginUtils.filter(plugins, \"cacheDidUpdate\"\n            /* CACHE_DID_UPDATE */\n            );\n\n            if (!(updatePlugins.length > 0)) {\n              _context4.next = 26;\n              break;\n            }\n\n            _context4.next = 23;\n            return matchWrapper({\n              cacheName: cacheName,\n              matchOptions: matchOptions,\n              request: effectiveRequest\n            });\n\n          case 23:\n            _context4.t0 = _context4.sent;\n            _context4.next = 27;\n            break;\n\n          case 26:\n            _context4.t0 = null;\n\n          case 27:\n            oldResponse = _context4.t0;\n\n            if (process.env.NODE_ENV !== 'production') {\n              logger.debug(\"Updating the '\".concat(cacheName, \"' cache with a new Response for \") + \"\".concat(getFriendlyURL(effectiveRequest.url), \".\"));\n            }\n\n            _context4.prev = 29;\n            _context4.next = 32;\n            return cache.put(effectiveRequest, responseToCache);\n\n          case 32:\n            _context4.next = 40;\n            break;\n\n          case 34:\n            _context4.prev = 34;\n            _context4.t1 = _context4[\"catch\"](29);\n\n            if (!(_context4.t1.name === 'QuotaExceededError')) {\n              _context4.next = 39;\n              break;\n            }\n\n            _context4.next = 39;\n            return executeQuotaErrorCallbacks();\n\n          case 39:\n            throw _context4.t1;\n\n          case 40:\n            _iterator4 = _createForOfIteratorHelper(updatePlugins);\n            _context4.prev = 41;\n\n            _iterator4.s();\n\n          case 43:\n            if ((_step4 = _iterator4.n()).done) {\n              _context4.next = 49;\n              break;\n            }\n\n            plugin = _step4.value;\n            _context4.next = 47;\n            return plugin[\"cacheDidUpdate\"\n            /* CACHE_DID_UPDATE */\n            ].call(plugin, {\n              cacheName: cacheName,\n              event: event,\n              oldResponse: oldResponse,\n              newResponse: responseToCache,\n              request: effectiveRequest\n            });\n\n          case 47:\n            _context4.next = 43;\n            break;\n\n          case 49:\n            _context4.next = 54;\n            break;\n\n          case 51:\n            _context4.prev = 51;\n            _context4.t2 = _context4[\"catch\"](41);\n\n            _iterator4.e(_context4.t2);\n\n          case 54:\n            _context4.prev = 54;\n\n            _iterator4.f();\n\n            return _context4.finish(54);\n\n          case 57:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[29, 34], [41, 51, 54, 57]]);\n  }));\n\n  return function putWrapper(_x4) {\n    return _ref8.apply(this, arguments);\n  };\n}();\n\nexport var cacheWrapper = {\n  put: putWrapper,\n  match: matchWrapper\n};","map":{"version":3,"sources":["C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/workbox-core/_private/cacheWrapper.js"],"names":["assert","executeQuotaErrorCallbacks","getFriendlyURL","logger","pluginUtils","WorkboxError","_getEffectiveRequest","request","mode","plugins","cacheKeyWillBeUsedPlugins","filter","effectiveRequest","plugin","call","Request","process","env","NODE_ENV","isInstance","moduleName","funcName","isReturnValueProblem","_isResponseSafeToCache","response","event","responseToCache","pluginsUsed","pluginMethod","Response","status","warn","url","debug","undefined","matchWrapper","cacheName","matchOptions","self","caches","open","cache","match","cachedResponse","putWrapper","method","error","updatePlugins","length","oldResponse","put","name","newResponse","cacheWrapper"],"mappings":"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","sourcesContent":["/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { assert } from './assert.js';\r\nimport { executeQuotaErrorCallbacks } from './executeQuotaErrorCallbacks.js';\r\nimport { getFriendlyURL } from './getFriendlyURL.js';\r\nimport { logger } from './logger.js';\r\nimport { pluginUtils } from '../utils/pluginUtils.js';\r\nimport { WorkboxError } from './WorkboxError.js';\r\nimport '../_version.js';\r\n/**\r\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\r\n * executes any of those callbacks found in sequence. The final `Request` object\r\n * returned by the last plugin is treated as the cache key for cache reads\r\n * and/or writes.\r\n *\r\n * @param {Object} options\r\n * @param {Request} options.request\r\n * @param {string} options.mode\r\n * @param {Array<Object>} [options.plugins=[]]\r\n * @return {Promise<Request>}\r\n *\r\n * @private\r\n * @memberof module:workbox-core\r\n */\r\nconst _getEffectiveRequest = async ({ request, mode, plugins = [], }) => {\r\n    const cacheKeyWillBeUsedPlugins = pluginUtils.filter(plugins, \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */);\r\n    let effectiveRequest = request;\r\n    for (const plugin of cacheKeyWillBeUsedPlugins) {\r\n        effectiveRequest = await plugin[\"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */].call(plugin, { mode, request: effectiveRequest });\r\n        if (typeof effectiveRequest === 'string') {\r\n            effectiveRequest = new Request(effectiveRequest);\r\n        }\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isInstance(effectiveRequest, Request, {\r\n                moduleName: 'Plugin',\r\n                funcName: \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */,\r\n                isReturnValueProblem: true,\r\n            });\r\n        }\r\n    }\r\n    return effectiveRequest;\r\n};\r\n/**\r\n * This method will call cacheWillUpdate on the available plugins (or use\r\n * status === 200) to determine if the Response is safe and valid to cache.\r\n *\r\n * @param {Object} options\r\n * @param {Request} options.request\r\n * @param {Response} options.response\r\n * @param {Event} [options.event]\r\n * @param {Array<Object>} [options.plugins=[]]\r\n * @return {Promise<Response>}\r\n *\r\n * @private\r\n * @memberof module:workbox-core\r\n */\r\nconst _isResponseSafeToCache = async ({ request, response, event, plugins = [], }) => {\r\n    let responseToCache = response;\r\n    let pluginsUsed = false;\r\n    for (const plugin of plugins) {\r\n        if (\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */ in plugin) {\r\n            pluginsUsed = true;\r\n            const pluginMethod = plugin[\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */];\r\n            responseToCache = await pluginMethod.call(plugin, {\r\n                request,\r\n                response: responseToCache,\r\n                event,\r\n            });\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                if (responseToCache) {\r\n                    assert.isInstance(responseToCache, Response, {\r\n                        moduleName: 'Plugin',\r\n                        funcName: \"cacheWillUpdate\" /* CACHE_WILL_UPDATE */,\r\n                        isReturnValueProblem: true,\r\n                    });\r\n                }\r\n            }\r\n            if (!responseToCache) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (!pluginsUsed) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (responseToCache) {\r\n                if (responseToCache.status !== 200) {\r\n                    if (responseToCache.status === 0) {\r\n                        logger.warn(`The response for '${request.url}' is an opaque ` +\r\n                            `response. The caching strategy that you're using will not ` +\r\n                            `cache opaque responses by default.`);\r\n                    }\r\n                    else {\r\n                        logger.debug(`The response for '${request.url}' returned ` +\r\n                            `a status code of '${response.status}' and won't be cached as a ` +\r\n                            `result.`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        responseToCache = responseToCache && responseToCache.status === 200 ?\r\n            responseToCache : undefined;\r\n    }\r\n    return responseToCache ? responseToCache : null;\r\n};\r\n/**\r\n * This is a wrapper around cache.match().\r\n *\r\n * @param {Object} options\r\n * @param {string} options.cacheName Name of the cache to match against.\r\n * @param {Request} options.request The Request that will be used to look up\r\n *     cache entries.\r\n * @param {Event} [options.event] The event that prompted the action.\r\n * @param {Object} [options.matchOptions] Options passed to cache.match().\r\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\r\n * @return {Response} A cached response if available.\r\n *\r\n * @private\r\n * @memberof module:workbox-core\r\n */\r\nconst matchWrapper = async ({ cacheName, request, event, matchOptions, plugins = [], }) => {\r\n    const cache = await self.caches.open(cacheName);\r\n    const effectiveRequest = await _getEffectiveRequest({\r\n        plugins, request, mode: 'read'\r\n    });\r\n    let cachedResponse = await cache.match(effectiveRequest, matchOptions);\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (cachedResponse) {\r\n            logger.debug(`Found a cached response in '${cacheName}'.`);\r\n        }\r\n        else {\r\n            logger.debug(`No cached response found in '${cacheName}'.`);\r\n        }\r\n    }\r\n    for (const plugin of plugins) {\r\n        if (\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */ in plugin) {\r\n            const pluginMethod = plugin[\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */];\r\n            cachedResponse = await pluginMethod.call(plugin, {\r\n                cacheName,\r\n                event,\r\n                matchOptions,\r\n                cachedResponse,\r\n                request: effectiveRequest,\r\n            });\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                if (cachedResponse) {\r\n                    assert.isInstance(cachedResponse, Response, {\r\n                        moduleName: 'Plugin',\r\n                        funcName: \"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */,\r\n                        isReturnValueProblem: true,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return cachedResponse;\r\n};\r\n/**\r\n * Wrapper around cache.put().\r\n *\r\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\r\n * `matchOptions` when determining what the old entry is.\r\n *\r\n * @param {Object} options\r\n * @param {string} options.cacheName\r\n * @param {Request} options.request\r\n * @param {Response} options.response\r\n * @param {Event} [options.event]\r\n * @param {Array<Object>} [options.plugins=[]]\r\n * @param {Object} [options.matchOptions]\r\n *\r\n * @private\r\n * @memberof module:workbox-core\r\n */\r\nconst putWrapper = async ({ cacheName, request, response, event, plugins = [], matchOptions, }) => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (request.method && request.method !== 'GET') {\r\n            throw new WorkboxError('attempt-to-cache-non-get-request', {\r\n                url: getFriendlyURL(request.url),\r\n                method: request.method,\r\n            });\r\n        }\r\n    }\r\n    const effectiveRequest = await _getEffectiveRequest({\r\n        plugins, request, mode: 'write'\r\n    });\r\n    if (!response) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            logger.error(`Cannot cache non-existent response for ` +\r\n                `'${getFriendlyURL(effectiveRequest.url)}'.`);\r\n        }\r\n        throw new WorkboxError('cache-put-with-no-response', {\r\n            url: getFriendlyURL(effectiveRequest.url),\r\n        });\r\n    }\r\n    const responseToCache = await _isResponseSafeToCache({\r\n        event,\r\n        plugins,\r\n        response,\r\n        request: effectiveRequest,\r\n    });\r\n    if (!responseToCache) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` +\r\n                `not be cached.`, responseToCache);\r\n        }\r\n        return;\r\n    }\r\n    const cache = await self.caches.open(cacheName);\r\n    const updatePlugins = pluginUtils.filter(plugins, \"cacheDidUpdate\" /* CACHE_DID_UPDATE */);\r\n    const oldResponse = updatePlugins.length > 0 ?\r\n        await matchWrapper({ cacheName, matchOptions, request: effectiveRequest }) :\r\n        null;\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        logger.debug(`Updating the '${cacheName}' cache with a new Response for ` +\r\n            `${getFriendlyURL(effectiveRequest.url)}.`);\r\n    }\r\n    try {\r\n        await cache.put(effectiveRequest, responseToCache);\r\n    }\r\n    catch (error) {\r\n        // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\r\n        if (error.name === 'QuotaExceededError') {\r\n            await executeQuotaErrorCallbacks();\r\n        }\r\n        throw error;\r\n    }\r\n    for (const plugin of updatePlugins) {\r\n        await plugin[\"cacheDidUpdate\" /* CACHE_DID_UPDATE */].call(plugin, {\r\n            cacheName,\r\n            event,\r\n            oldResponse,\r\n            newResponse: responseToCache,\r\n            request: effectiveRequest,\r\n        });\r\n    }\r\n};\r\nexport const cacheWrapper = {\r\n    put: putWrapper,\r\n    match: matchWrapper,\r\n};\r\n"]},"metadata":{},"sourceType":"module"}