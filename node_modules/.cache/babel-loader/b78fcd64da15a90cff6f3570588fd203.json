{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _slicedToArray from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\nimport '../_version.js';\n/**\r\n * A class that wraps common IndexedDB functionality in a promise-based API.\r\n * It exposes all the underlying power and functionality of IndexedDB, but\r\n * wraps the most commonly used features in a way that's much simpler to use.\r\n *\r\n * @private\r\n */\n\nexport var DBWrapper = /*#__PURE__*/function () {\n  /**\r\n   * @param {string} name\r\n   * @param {number} version\r\n   * @param {Object=} [callback]\r\n   * @param {!Function} [callbacks.onupgradeneeded]\r\n   * @param {!Function} [callbacks.onversionchange] Defaults to\r\n   *     DBWrapper.prototype._onversionchange when not specified.\r\n   * @private\r\n   */\n  function DBWrapper(name, version) {\n    var _this = this;\n\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        onupgradeneeded = _ref.onupgradeneeded,\n        onversionchange = _ref.onversionchange;\n\n    _classCallCheck(this, DBWrapper);\n\n    this._db = null;\n    this._name = name;\n    this._version = version;\n    this._onupgradeneeded = onupgradeneeded;\n\n    this._onversionchange = onversionchange || function () {\n      return _this.close();\n    };\n  }\n  /**\r\n   * Returns the IDBDatabase instance (not normally needed).\r\n   * @return {IDBDatabase|undefined}\r\n   *\r\n   * @private\r\n   */\n\n\n  _createClass(DBWrapper, [{\n    key: \"db\",\n    get: function get() {\n      return this._db;\n    }\n    /**\r\n     * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\r\n     * callback, and added an onversionchange callback to the database.\r\n     *\r\n     * @return {IDBDatabase}\r\n     * @private\r\n     */\n\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._db) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                _context.next = 4;\n                return new Promise(function (resolve, reject) {\n                  // This flag is flipped to true if the timeout callback runs prior\n                  // to the request failing or succeeding. Note: we use a timeout instead\n                  // of an onblocked handler since there are cases where onblocked will\n                  // never never run. A timeout better handles all possible scenarios:\n                  // https://github.com/w3c/IndexedDB/issues/223\n                  var openRequestTimedOut = false;\n                  setTimeout(function () {\n                    openRequestTimedOut = true;\n                    reject(new Error('The open request was blocked and timed out'));\n                  }, _this2.OPEN_TIMEOUT);\n                  var openRequest = indexedDB.open(_this2._name, _this2._version);\n\n                  openRequest.onerror = function () {\n                    return reject(openRequest.error);\n                  };\n\n                  openRequest.onupgradeneeded = function (evt) {\n                    if (openRequestTimedOut) {\n                      openRequest.transaction.abort();\n                      openRequest.result.close();\n                    } else if (typeof _this2._onupgradeneeded === 'function') {\n                      _this2._onupgradeneeded(evt);\n                    }\n                  };\n\n                  openRequest.onsuccess = function () {\n                    var db = openRequest.result;\n\n                    if (openRequestTimedOut) {\n                      db.close();\n                    } else {\n                      db.onversionchange = _this2._onversionchange.bind(_this2);\n                      resolve(db);\n                    }\n                  };\n                });\n\n              case 4:\n                this._db = _context.sent;\n                return _context.abrupt(\"return\", this);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function open() {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n    /**\r\n     * Polyfills the native `getKey()` method. Note, this is overridden at\r\n     * runtime if the browser supports the native method.\r\n     *\r\n     * @param {string} storeName\r\n     * @param {*} query\r\n     * @return {Array}\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getKey\",\n    value: function () {\n      var _getKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(storeName, query) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.getAllKeys(storeName, query, 1);\n\n              case 2:\n                return _context2.abrupt(\"return\", _context2.sent[0]);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getKey(_x, _x2) {\n        return _getKey.apply(this, arguments);\n      }\n\n      return getKey;\n    }()\n    /**\r\n     * Polyfills the native `getAll()` method. Note, this is overridden at\r\n     * runtime if the browser supports the native method.\r\n     *\r\n     * @param {string} storeName\r\n     * @param {*} query\r\n     * @param {number} count\r\n     * @return {Array}\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function () {\n      var _getAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(storeName, query, count) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.getAllMatching(storeName, {\n                  query: query,\n                  count: count\n                });\n\n              case 2:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getAll(_x3, _x4, _x5) {\n        return _getAll.apply(this, arguments);\n      }\n\n      return getAll;\n    }()\n    /**\r\n     * Polyfills the native `getAllKeys()` method. Note, this is overridden at\r\n     * runtime if the browser supports the native method.\r\n     *\r\n     * @param {string} storeName\r\n     * @param {*} query\r\n     * @param {number} count\r\n     * @return {Array}\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getAllKeys\",\n    value: function () {\n      var _getAllKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(storeName, query, count) {\n        var entries;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.getAllMatching(storeName, {\n                  query: query,\n                  count: count,\n                  includeKeys: true\n                });\n\n              case 2:\n                entries = _context4.sent;\n                return _context4.abrupt(\"return\", entries.map(function (entry) {\n                  return entry.key;\n                }));\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getAllKeys(_x6, _x7, _x8) {\n        return _getAllKeys.apply(this, arguments);\n      }\n\n      return getAllKeys;\n    }()\n    /**\r\n     * Supports flexible lookup in an object store by specifying an index,\r\n     * query, direction, and count. This method returns an array of objects\r\n     * with the signature .\r\n     *\r\n     * @param {string} storeName\r\n     * @param {Object} [opts]\r\n     * @param {string} [opts.index] The index to use (if specified).\r\n     * @param {*} [opts.query]\r\n     * @param {IDBCursorDirection} [opts.direction]\r\n     * @param {number} [opts.count] The max number of results to return.\r\n     * @param {boolean} [opts.includeKeys] When true, the structure of the\r\n     *     returned objects is changed from an array of values to an array of\r\n     *     objects in the form {key, primaryKey, value}.\r\n     * @return {Array}\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getAllMatching\",\n    value: function () {\n      var _getAllMatching = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(storeName) {\n        var _ref2,\n            index,\n            _ref2$query,\n            query,\n            _ref2$direction,\n            direction,\n            count,\n            _ref2$includeKeys,\n            includeKeys,\n            _args5 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _ref2 = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {}, index = _ref2.index, _ref2$query = _ref2.query, query = _ref2$query === void 0 ? null : _ref2$query, _ref2$direction = _ref2.direction, direction = _ref2$direction === void 0 ? 'next' : _ref2$direction, count = _ref2.count, _ref2$includeKeys = _ref2.includeKeys, includeKeys = _ref2$includeKeys === void 0 ? false : _ref2$includeKeys;\n                _context5.next = 3;\n                return this.transaction([storeName], 'readonly', function (txn, done) {\n                  var store = txn.objectStore(storeName);\n                  var target = index ? store.index(index) : store;\n                  var results = [];\n                  var request = target.openCursor(query, direction);\n\n                  request.onsuccess = function () {\n                    var cursor = request.result;\n\n                    if (cursor) {\n                      results.push(includeKeys ? cursor : cursor.value);\n\n                      if (count && results.length >= count) {\n                        done(results);\n                      } else {\n                        cursor.continue();\n                      }\n                    } else {\n                      done(results);\n                    }\n                  };\n                });\n\n              case 3:\n                return _context5.abrupt(\"return\", _context5.sent);\n\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getAllMatching(_x9) {\n        return _getAllMatching.apply(this, arguments);\n      }\n\n      return getAllMatching;\n    }()\n    /**\r\n     * Accepts a list of stores, a transaction type, and a callback and\r\n     * performs a transaction. A promise is returned that resolves to whatever\r\n     * value the callback chooses. The callback holds all the transaction logic\r\n     * and is invoked with two arguments:\r\n     *   1. The IDBTransaction object\r\n     *   2. A `done` function, that's used to resolve the promise when\r\n     *      when the transaction is done, if passed a value, the promise is\r\n     *      resolved to that value.\r\n     *\r\n     * @param {Array<string>} storeNames An array of object store names\r\n     *     involved in the transaction.\r\n     * @param {string} type Can be `readonly` or `readwrite`.\r\n     * @param {!Function} callback\r\n     * @return {*} The result of the transaction ran by the callback.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"transaction\",\n    value: function () {\n      var _transaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(storeNames, type, callback) {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.open();\n\n              case 2:\n                _context6.next = 4;\n                return new Promise(function (resolve, reject) {\n                  var txn = _this3._db.transaction(storeNames, type);\n\n                  txn.onabort = function () {\n                    return reject(txn.error);\n                  };\n\n                  txn.oncomplete = function () {\n                    return resolve();\n                  };\n\n                  callback(txn, function (value) {\n                    return resolve(value);\n                  });\n                });\n\n              case 4:\n                return _context6.abrupt(\"return\", _context6.sent);\n\n              case 5:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function transaction(_x10, _x11, _x12) {\n        return _transaction.apply(this, arguments);\n      }\n\n      return transaction;\n    }()\n    /**\r\n     * Delegates async to a native IDBObjectStore method.\r\n     *\r\n     * @param {string} method The method name.\r\n     * @param {string} storeName The object store name.\r\n     * @param {string} type Can be `readonly` or `readwrite`.\r\n     * @param {...*} args The list of args to pass to the native method.\r\n     * @return {*} The result of the transaction.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"_call\",\n    value: function () {\n      var _call2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(method, storeName, type) {\n        var _len,\n            args,\n            _key,\n            callback,\n            _args7 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                for (_len = _args7.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n                  args[_key - 3] = _args7[_key];\n                }\n\n                callback = function callback(txn, done) {\n                  var objStore = txn.objectStore(storeName); // TODO(philipwalton): Fix this underlying TS2684 error.\n                  // @ts-ignore\n\n                  var request = objStore[method].apply(objStore, args);\n\n                  request.onsuccess = function () {\n                    return done(request.result);\n                  };\n                };\n\n                _context7.next = 4;\n                return this.transaction([storeName], type, callback);\n\n              case 4:\n                return _context7.abrupt(\"return\", _context7.sent);\n\n              case 5:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function _call(_x13, _x14, _x15) {\n        return _call2.apply(this, arguments);\n      }\n\n      return _call;\n    }()\n    /**\r\n     * Closes the connection opened by `DBWrapper.open()`. Generally this method\r\n     * doesn't need to be called since:\r\n     *   1. It's usually better to keep a connection open since opening\r\n     *      a new connection is somewhat slow.\r\n     *   2. Connections are automatically closed when the reference is\r\n     *      garbage collected.\r\n     * The primary use case for needing to close a connection is when another\r\n     * reference (typically in another tab) needs to upgrade it and would be\r\n     * blocked by the current, open connection.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._db) {\n        this._db.close();\n\n        this._db = null;\n      }\n    }\n  }]);\n\n  return DBWrapper;\n}(); // Exposed on the prototype to let users modify the default timeout on a\n// per-instance or global basis.\n\nDBWrapper.prototype.OPEN_TIMEOUT = 2000; // Wrap native IDBObjectStore methods according to their mode.\n\nvar methodsToWrap = {\n  readonly: ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n  readwrite: ['add', 'put', 'clear', 'delete']\n};\n\nvar _loop = function _loop() {\n  var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n      mode = _Object$entries$_i[0],\n      methods = _Object$entries$_i[1];\n\n  var _iterator = _createForOfIteratorHelper(methods),\n      _step;\n\n  try {\n    var _loop2 = function _loop2() {\n      var method = _step.value;\n\n      if (method in IDBObjectStore.prototype) {\n        // Don't use arrow functions here since we're outside of the class.\n        DBWrapper.prototype[method] = /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(storeName) {\n            var _len2,\n                args,\n                _key2,\n                _args8 = arguments;\n\n            return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n              while (1) {\n                switch (_context8.prev = _context8.next) {\n                  case 0:\n                    for (_len2 = _args8.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                      args[_key2 - 1] = _args8[_key2];\n                    }\n\n                    _context8.next = 3;\n                    return this._call.apply(this, [method, storeName, mode].concat(args));\n\n                  case 3:\n                    return _context8.abrupt(\"return\", _context8.sent);\n\n                  case 4:\n                  case \"end\":\n                    return _context8.stop();\n                }\n              }\n            }, _callee8, this);\n          }));\n\n          return function (_x16) {\n            return _ref3.apply(this, arguments);\n          };\n        }();\n      }\n    };\n\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop2();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\n\nfor (var _i = 0, _Object$entries = Object.entries(methodsToWrap); _i < _Object$entries.length; _i++) {\n  _loop();\n}","map":{"version":3,"sources":["C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/workbox-core/_private/DBWrapper.js"],"names":["DBWrapper","name","version","onupgradeneeded","onversionchange","_db","_name","_version","_onupgradeneeded","_onversionchange","close","Promise","resolve","reject","openRequestTimedOut","setTimeout","Error","OPEN_TIMEOUT","openRequest","indexedDB","open","onerror","error","evt","transaction","abort","result","onsuccess","db","bind","storeName","query","getAllKeys","count","getAllMatching","includeKeys","entries","map","entry","key","index","direction","txn","done","store","objectStore","target","results","request","openCursor","cursor","push","value","length","continue","storeNames","type","callback","onabort","oncomplete","method","args","objStore","apply","prototype","methodsToWrap","readonly","readwrite","mode","methods","IDBObjectStore","_call","Object"],"mappings":"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","sourcesContent":["/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport '../_version.js';\r\n/**\r\n * A class that wraps common IndexedDB functionality in a promise-based API.\r\n * It exposes all the underlying power and functionality of IndexedDB, but\r\n * wraps the most commonly used features in a way that's much simpler to use.\r\n *\r\n * @private\r\n */\r\nexport class DBWrapper {\r\n    /**\r\n     * @param {string} name\r\n     * @param {number} version\r\n     * @param {Object=} [callback]\r\n     * @param {!Function} [callbacks.onupgradeneeded]\r\n     * @param {!Function} [callbacks.onversionchange] Defaults to\r\n     *     DBWrapper.prototype._onversionchange when not specified.\r\n     * @private\r\n     */\r\n    constructor(name, version, { onupgradeneeded, onversionchange, } = {}) {\r\n        this._db = null;\r\n        this._name = name;\r\n        this._version = version;\r\n        this._onupgradeneeded = onupgradeneeded;\r\n        this._onversionchange = onversionchange || (() => this.close());\r\n    }\r\n    /**\r\n     * Returns the IDBDatabase instance (not normally needed).\r\n     * @return {IDBDatabase|undefined}\r\n     *\r\n     * @private\r\n     */\r\n    get db() {\r\n        return this._db;\r\n    }\r\n    /**\r\n     * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\r\n     * callback, and added an onversionchange callback to the database.\r\n     *\r\n     * @return {IDBDatabase}\r\n     * @private\r\n     */\r\n    async open() {\r\n        if (this._db)\r\n            return;\r\n        this._db = await new Promise((resolve, reject) => {\r\n            // This flag is flipped to true if the timeout callback runs prior\r\n            // to the request failing or succeeding. Note: we use a timeout instead\r\n            // of an onblocked handler since there are cases where onblocked will\r\n            // never never run. A timeout better handles all possible scenarios:\r\n            // https://github.com/w3c/IndexedDB/issues/223\r\n            let openRequestTimedOut = false;\r\n            setTimeout(() => {\r\n                openRequestTimedOut = true;\r\n                reject(new Error('The open request was blocked and timed out'));\r\n            }, this.OPEN_TIMEOUT);\r\n            const openRequest = indexedDB.open(this._name, this._version);\r\n            openRequest.onerror = () => reject(openRequest.error);\r\n            openRequest.onupgradeneeded = (evt) => {\r\n                if (openRequestTimedOut) {\r\n                    openRequest.transaction.abort();\r\n                    openRequest.result.close();\r\n                }\r\n                else if (typeof this._onupgradeneeded === 'function') {\r\n                    this._onupgradeneeded(evt);\r\n                }\r\n            };\r\n            openRequest.onsuccess = () => {\r\n                const db = openRequest.result;\r\n                if (openRequestTimedOut) {\r\n                    db.close();\r\n                }\r\n                else {\r\n                    db.onversionchange = this._onversionchange.bind(this);\r\n                    resolve(db);\r\n                }\r\n            };\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * Polyfills the native `getKey()` method. Note, this is overridden at\r\n     * runtime if the browser supports the native method.\r\n     *\r\n     * @param {string} storeName\r\n     * @param {*} query\r\n     * @return {Array}\r\n     * @private\r\n     */\r\n    async getKey(storeName, query) {\r\n        return (await this.getAllKeys(storeName, query, 1))[0];\r\n    }\r\n    /**\r\n     * Polyfills the native `getAll()` method. Note, this is overridden at\r\n     * runtime if the browser supports the native method.\r\n     *\r\n     * @param {string} storeName\r\n     * @param {*} query\r\n     * @param {number} count\r\n     * @return {Array}\r\n     * @private\r\n     */\r\n    async getAll(storeName, query, count) {\r\n        return await this.getAllMatching(storeName, { query, count });\r\n    }\r\n    /**\r\n     * Polyfills the native `getAllKeys()` method. Note, this is overridden at\r\n     * runtime if the browser supports the native method.\r\n     *\r\n     * @param {string} storeName\r\n     * @param {*} query\r\n     * @param {number} count\r\n     * @return {Array}\r\n     * @private\r\n     */\r\n    async getAllKeys(storeName, query, count) {\r\n        const entries = await this.getAllMatching(storeName, { query, count, includeKeys: true });\r\n        return entries.map((entry) => entry.key);\r\n    }\r\n    /**\r\n     * Supports flexible lookup in an object store by specifying an index,\r\n     * query, direction, and count. This method returns an array of objects\r\n     * with the signature .\r\n     *\r\n     * @param {string} storeName\r\n     * @param {Object} [opts]\r\n     * @param {string} [opts.index] The index to use (if specified).\r\n     * @param {*} [opts.query]\r\n     * @param {IDBCursorDirection} [opts.direction]\r\n     * @param {number} [opts.count] The max number of results to return.\r\n     * @param {boolean} [opts.includeKeys] When true, the structure of the\r\n     *     returned objects is changed from an array of values to an array of\r\n     *     objects in the form {key, primaryKey, value}.\r\n     * @return {Array}\r\n     * @private\r\n     */\r\n    async getAllMatching(storeName, { index, query = null, // IE/Edge errors if query === `undefined`.\r\n    direction = 'next', count, includeKeys = false, } = {}) {\r\n        return await this.transaction([storeName], 'readonly', (txn, done) => {\r\n            const store = txn.objectStore(storeName);\r\n            const target = index ? store.index(index) : store;\r\n            const results = [];\r\n            const request = target.openCursor(query, direction);\r\n            request.onsuccess = () => {\r\n                const cursor = request.result;\r\n                if (cursor) {\r\n                    results.push(includeKeys ? cursor : cursor.value);\r\n                    if (count && results.length >= count) {\r\n                        done(results);\r\n                    }\r\n                    else {\r\n                        cursor.continue();\r\n                    }\r\n                }\r\n                else {\r\n                    done(results);\r\n                }\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Accepts a list of stores, a transaction type, and a callback and\r\n     * performs a transaction. A promise is returned that resolves to whatever\r\n     * value the callback chooses. The callback holds all the transaction logic\r\n     * and is invoked with two arguments:\r\n     *   1. The IDBTransaction object\r\n     *   2. A `done` function, that's used to resolve the promise when\r\n     *      when the transaction is done, if passed a value, the promise is\r\n     *      resolved to that value.\r\n     *\r\n     * @param {Array<string>} storeNames An array of object store names\r\n     *     involved in the transaction.\r\n     * @param {string} type Can be `readonly` or `readwrite`.\r\n     * @param {!Function} callback\r\n     * @return {*} The result of the transaction ran by the callback.\r\n     * @private\r\n     */\r\n    async transaction(storeNames, type, callback) {\r\n        await this.open();\r\n        return await new Promise((resolve, reject) => {\r\n            const txn = this._db.transaction(storeNames, type);\r\n            txn.onabort = () => reject(txn.error);\r\n            txn.oncomplete = () => resolve();\r\n            callback(txn, (value) => resolve(value));\r\n        });\r\n    }\r\n    /**\r\n     * Delegates async to a native IDBObjectStore method.\r\n     *\r\n     * @param {string} method The method name.\r\n     * @param {string} storeName The object store name.\r\n     * @param {string} type Can be `readonly` or `readwrite`.\r\n     * @param {...*} args The list of args to pass to the native method.\r\n     * @return {*} The result of the transaction.\r\n     * @private\r\n     */\r\n    async _call(method, storeName, type, ...args) {\r\n        const callback = (txn, done) => {\r\n            const objStore = txn.objectStore(storeName);\r\n            // TODO(philipwalton): Fix this underlying TS2684 error.\r\n            // @ts-ignore\r\n            const request = objStore[method].apply(objStore, args);\r\n            request.onsuccess = () => done(request.result);\r\n        };\r\n        return await this.transaction([storeName], type, callback);\r\n    }\r\n    /**\r\n     * Closes the connection opened by `DBWrapper.open()`. Generally this method\r\n     * doesn't need to be called since:\r\n     *   1. It's usually better to keep a connection open since opening\r\n     *      a new connection is somewhat slow.\r\n     *   2. Connections are automatically closed when the reference is\r\n     *      garbage collected.\r\n     * The primary use case for needing to close a connection is when another\r\n     * reference (typically in another tab) needs to upgrade it and would be\r\n     * blocked by the current, open connection.\r\n     *\r\n     * @private\r\n     */\r\n    close() {\r\n        if (this._db) {\r\n            this._db.close();\r\n            this._db = null;\r\n        }\r\n    }\r\n}\r\n// Exposed on the prototype to let users modify the default timeout on a\r\n// per-instance or global basis.\r\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\r\n// Wrap native IDBObjectStore methods according to their mode.\r\nconst methodsToWrap = {\r\n    readonly: ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\r\n    readwrite: ['add', 'put', 'clear', 'delete'],\r\n};\r\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\r\n    for (const method of methods) {\r\n        if (method in IDBObjectStore.prototype) {\r\n            // Don't use arrow functions here since we're outside of the class.\r\n            DBWrapper.prototype[method] =\r\n                async function (storeName, ...args) {\r\n                    return await this._call(method, storeName, mode, ...args);\r\n                };\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}