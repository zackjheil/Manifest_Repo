{"ast":null,"code":"import logger from '../../utils/logger';\nimport isSubset from '../../utils/isSubset';\nimport success from '../../api-utils/success';\nimport error from '../../api-utils/error';\nimport showUserErrors from '../../api-utils/showUserErrors';\nimport selectionLevel from '../../api-utils/selectionLevel';\nexport default function set(newDocument, options = {\n  keys: false\n}) {\n  let collectionName = this.collectionName;\n  let docSelectionCriteria = this.docSelectionCriteria;\n  let currentSelectionLevel = selectionLevel.call(this);\n  return new Promise((resolve, reject) => {\n    // set collection\n    this.setCollection = () => {\n      this.lf[collectionName].clear().then(() => {\n        if (!options.keys) {\n          newDocument.forEach(doc => {\n            this.add(doc);\n          });\n          resolve(success.call(this, `Collection \"${collectionName}\" set with ${newDocument.length} Documents`, newDocument));\n        } else {\n          console.log('keys provided'); // check that every document in array has a _key property\n\n          let docsWithoutKey = 0;\n          newDocument.forEach(doc => {\n            if (!doc.hasOwnProperty('_key')) {\n              docsWithoutKey++;\n            }\n          });\n\n          if (docsWithoutKey) {\n            reject(error.call(this, `Documents provided to .set() in an array must each have a _key property set to a string.`));\n          } else {\n            newDocument.forEach(doc => {\n              let key = doc._key;\n              delete doc._key;\n              this.add(doc, key);\n            });\n            resolve(success.call(this, `Collection \"${collectionName}\" set with ${newDocument.length} Documents`, newDocument));\n          }\n        }\n      }).catch(err => {\n        reject(error.call(this, `Could not set ${collectionName} Collection with data ${JSON.stringify(newDocument)}.`));\n      });\n    }; // set document\n\n\n    this.setDocument = () => {\n      // set document by criteria\n      this.setDocumentByCriteria = () => {\n        let docsToSet = [];\n        this.lf[collectionName].iterate((value, key) => {\n          if (isSubset(value, docSelectionCriteria)) {\n            docsToSet.push({\n              key,\n              newDocument\n            });\n          }\n        }).then(() => {\n          if (!docsToSet.length) {\n            reject(error.call(this, `No Documents found in ${collectionName} Collection with criteria ${JSON.stringify(docSelectionCriteria)}.`));\n          }\n\n          if (docsToSet.length > 1) {\n            logger.warn.call(this, `Multiple documents (${docsToSet.length}) with ${JSON.stringify(docSelectionCriteria)} found for setting.`);\n          }\n        }).then(() => {\n          docsToSet.forEach((docToSet, index) => {\n            this.lf[collectionName].setItem(docToSet.key, docToSet.newDocument).then(value => {\n              if (index === docsToSet.length - 1) {\n                resolve(success.call(this, `${docsToSet.length} Document${docsToSet.length > 1 ? 's' : ''} in \"${collectionName}\" collection with ${JSON.stringify(docSelectionCriteria)} set to:`, newDocument));\n              }\n            }).catch(err => {\n              reject(error.call(this, `Could not set ${docsToSet.length} Documents in ${collectionName} Collection.`));\n            });\n          });\n        });\n      }; // set document by key\n\n\n      this.setDocumentByKey = () => {\n        this.lf[collectionName].setItem(docSelectionCriteria, newDocument).then(value => {\n          resolve(success.call(this, `Document in \"${collectionName}\" collection with key ${JSON.stringify(docSelectionCriteria)} set to:`, newDocument));\n        }).catch(err => {\n          reject(error.call(this, `Document in \"${collectionName}\" collection with key ${JSON.stringify(docSelectionCriteria)} could not be set.`));\n        });\n      };\n\n      if (typeof docSelectionCriteria == 'object') {\n        return this.setDocumentByCriteria();\n      } else {\n        return this.setDocumentByKey();\n      }\n    }; // check for user errors\n\n\n    if (!newDocument) {\n      this.userErrors.push('No new Document object provided to set() method. Use an object e.g. { id: 1, name: \"Bill\", age: 47 }');\n    } else if (currentSelectionLevel === 'doc') {\n      if (!(typeof newDocument == 'object' && newDocument instanceof Array == false)) {\n        this.userErrors.push('Data passed to .set() must be an object. Not an array, string, number or boolean.');\n      }\n    } else if (currentSelectionLevel === 'collection') {\n      if (!(typeof newDocument == 'object' && newDocument instanceof Array == true)) {\n        this.userErrors.push('Data passed to .set() must be an array of objects. Not an object, string, number or boolean.');\n      }\n    }\n\n    if (!this.userErrors.length) {\n      if (currentSelectionLevel == 'collection') {\n        return this.setCollection();\n      } else if (currentSelectionLevel == 'doc') {\n        return this.setDocument();\n      }\n    } else {\n      showUserErrors.call(this);\n    }\n  });\n}","map":{"version":3,"sources":["/Users/jemvandeworp/Documents/GitHub/Manifest_Repo/node_modules/localbase/localbase/api/actions/set.js"],"names":["logger","isSubset","success","error","showUserErrors","selectionLevel","set","newDocument","options","keys","collectionName","docSelectionCriteria","currentSelectionLevel","call","Promise","resolve","reject","setCollection","lf","clear","then","forEach","doc","add","length","console","log","docsWithoutKey","hasOwnProperty","key","_key","catch","err","JSON","stringify","setDocument","setDocumentByCriteria","docsToSet","iterate","value","push","warn","docToSet","index","setItem","setDocumentByKey","userErrors","Array"],"mappings":"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","sourcesContent":["import logger from '../../utils/logger'\nimport isSubset from '../../utils/isSubset'\nimport success from '../../api-utils/success'\nimport error from '../../api-utils/error'\nimport showUserErrors from '../../api-utils/showUserErrors'\nimport selectionLevel from '../../api-utils/selectionLevel'\n\nexport default function set(newDocument, options = { keys: false }) {\n\n  let collectionName = this.collectionName\n  let docSelectionCriteria = this.docSelectionCriteria\n  let currentSelectionLevel = selectionLevel.call(this)\n\n  return new Promise((resolve, reject) => {\n\n    // set collection\n    this.setCollection = () => {\n      this.lf[collectionName].clear().then(() => {\n        if (!options.keys) {\n          newDocument.forEach(doc => {\n            this.add(doc)\n          })\n          resolve(\n            success.call(\n              this,\n              `Collection \"${ collectionName }\" set with ${ newDocument.length } Documents`, \n              newDocument\n            )\n          )\n        }\n        else {\n          console.log('keys provided')\n          // check that every document in array has a _key property\n          let docsWithoutKey = 0\n          newDocument.forEach(doc => {\n            if (!doc.hasOwnProperty('_key')) {\n              docsWithoutKey++\n            }\n          })\n          if (docsWithoutKey) {\n            reject(\n              error.call(\n                this,\n                `Documents provided to .set() in an array must each have a _key property set to a string.`\n              )\n            )\n          }\n          else {\n            newDocument.forEach(doc => {\n              let key = doc._key\n              delete doc._key\n              this.add(doc, key)\n            })\n            resolve(\n              success.call(\n                this,\n                `Collection \"${ collectionName }\" set with ${ newDocument.length } Documents`, \n                newDocument\n              )\n            )\n          }\n        }\n      }).catch(err => {\n        reject(\n          error.call(\n            this,\n            `Could not set ${ collectionName } Collection with data ${ JSON.stringify(newDocument) }.`\n          )\n        )\n      });\n    }\n\n    // set document\n    this.setDocument = () => {\n      \n      // set document by criteria\n      this.setDocumentByCriteria = () => {\n        let docsToSet = []\n        this.lf[collectionName].iterate((value, key) => {\n          if (isSubset(value, docSelectionCriteria)) {\n            docsToSet.push({ key, newDocument })\n          }\n        }).then(() => {\n          if (!docsToSet.length) {\n            reject(\n              error.call(\n                this,\n                `No Documents found in ${ collectionName } Collection with criteria ${ JSON.stringify(docSelectionCriteria) }.`\n              )\n            )\n          }\n          if (docsToSet.length > 1) {\n            logger.warn.call(this, `Multiple documents (${ docsToSet.length }) with ${ JSON.stringify(docSelectionCriteria) } found for setting.`)\n          }\n        }).then(() => {\n          docsToSet.forEach((docToSet, index) => {\n            this.lf[collectionName].setItem(docToSet.key, docToSet.newDocument).then(value => {\n  \n              if (index === (docsToSet.length - 1)) {\n                resolve(\n                  success.call(\n                    this,\n                    `${ docsToSet.length } Document${ docsToSet.length > 1 ? 's' : '' } in \"${ collectionName }\" collection with ${ JSON.stringify(docSelectionCriteria) } set to:`, \n                    newDocument\n                  )\n                )\n              }\n            }).catch(err => {\n              reject(\n                error.call(\n                  this,\n                  `Could not set ${ docsToSet.length } Documents in ${ collectionName } Collection.`\n                )\n              )\n            })\n          })\n        })\n      }\n  \n      // set document by key\n      this.setDocumentByKey = () => {\n        this.lf[collectionName].setItem(docSelectionCriteria, newDocument).then(value => {\n          resolve(\n            success.call(\n              this,\n              `Document in \"${ collectionName }\" collection with key ${ JSON.stringify(docSelectionCriteria) } set to:`,\n              newDocument\n            )\n          )\n        }).catch(err => {\n          reject(\n            error.call(\n              this,\n              `Document in \"${ collectionName }\" collection with key ${ JSON.stringify(docSelectionCriteria) } could not be set.`\n            )\n          )\n        })\n      }\n\n      if (typeof docSelectionCriteria == 'object') {\n        return this.setDocumentByCriteria()\n      }\n      else {\n        return this.setDocumentByKey()\n      }\n    }\n\n    // check for user errors\n    if (!newDocument) {\n      this.userErrors.push('No new Document object provided to set() method. Use an object e.g. { id: 1, name: \"Bill\", age: 47 }')\n    }\n    else if (currentSelectionLevel === 'doc') {\n      if (!(typeof newDocument == 'object' && newDocument instanceof Array == false)) {\n        this.userErrors.push('Data passed to .set() must be an object. Not an array, string, number or boolean.')\n      }\n    }\n    else if (currentSelectionLevel === 'collection') {\n      if (!(typeof newDocument == 'object' && newDocument instanceof Array == true)) {\n        this.userErrors.push('Data passed to .set() must be an array of objects. Not an object, string, number or boolean.')\n      }\n    }\n\n    if (!this.userErrors.length) {\n      if (currentSelectionLevel == 'collection') {\n        return this.setCollection()\n      }\n      else if (currentSelectionLevel == 'doc') {\n        return this.setDocument()\n      }\n    }\n    else {\n      showUserErrors.call(this)\n    }\n\n  })\n}"]},"metadata":{},"sourceType":"module"}