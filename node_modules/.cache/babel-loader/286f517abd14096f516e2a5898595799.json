{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _construct from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/construct\";\nimport _toConsumableArray from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport './_version.js';\n/**\r\n * The Router can be used to process a FetchEvent through one or more\r\n * [Routes]{@link module:workbox-routing.Route} responding  with a Request if\r\n * a matching route exists.\r\n *\r\n * If no route matches a given a request, the Router will use a \"default\"\r\n * handler if one is defined.\r\n *\r\n * Should the matching Route throw an error, the Router will use a \"catch\"\r\n * handler if one is defined to gracefully deal with issues and respond with a\r\n * Request.\r\n *\r\n * If a request matches multiple routes, the **earliest** registered route will\r\n * be used to respond to the request.\r\n *\r\n * @memberof module:workbox-routing\r\n */\n\nvar Router = /*#__PURE__*/function () {\n  /**\r\n   * Initializes a new Router.\r\n   */\n  function Router() {\n    _classCallCheck(this, Router);\n\n    this._routes = new Map();\n  }\n  /**\r\n   * @return {Map<string, Array<module:workbox-routing.Route>>} routes A `Map` of HTTP\r\n   * method name ('GET', etc.) to an array of all the corresponding `Route`\r\n   * instances that are registered.\r\n   */\n\n\n  _createClass(Router, [{\n    key: \"routes\",\n    get: function get() {\n      return this._routes;\n    }\n    /**\r\n     * Adds a fetch event listener to respond to events when a route matches\r\n     * the event's request.\r\n     */\n\n  }, {\n    key: \"addFetchListener\",\n    value: function addFetchListener() {\n      var _this = this;\n\n      // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n      self.addEventListener('fetch', function (event) {\n        var request = event.request;\n\n        var responsePromise = _this.handleRequest({\n          request: request,\n          event: event\n        });\n\n        if (responsePromise) {\n          event.respondWith(responsePromise);\n        }\n      });\n    }\n    /**\r\n     * Adds a message event listener for URLs to cache from the window.\r\n     * This is useful to cache resources loaded on the page prior to when the\r\n     * service worker started controlling it.\r\n     *\r\n     * The format of the message data sent from the window should be as follows.\r\n     * Where the `urlsToCache` array may consist of URL strings or an array of\r\n     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\r\n     *\r\n     * ```\r\n     * {\r\n     *   type: 'CACHE_URLS',\r\n     *   payload: {\r\n     *     urlsToCache: [\r\n     *       './script1.js',\r\n     *       './script2.js',\r\n     *       ['./script3.js', {mode: 'no-cors'}],\r\n     *     ],\r\n     *   },\r\n     * }\r\n     * ```\r\n     */\n\n  }, {\n    key: \"addCacheListener\",\n    value: function addCacheListener() {\n      var _this2 = this;\n\n      // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n      self.addEventListener('message', function (event) {\n        if (event.data && event.data.type === 'CACHE_URLS') {\n          var payload = event.data.payload;\n\n          if (process.env.NODE_ENV !== 'production') {\n            logger.debug(\"Caching URLs from the window\", payload.urlsToCache);\n          }\n\n          var requestPromises = Promise.all(payload.urlsToCache.map(function (entry) {\n            if (typeof entry === 'string') {\n              entry = [entry];\n            }\n\n            var request = _construct(Request, _toConsumableArray(entry));\n\n            return _this2.handleRequest({\n              request: request\n            }); // TODO(philipwalton): TypeScript errors without this typecast for\n            // some reason (probably a bug). The real type here should work but\n            // doesn't: `Array<Promise<Response> | undefined>`.\n          })); // TypeScript\n\n          event.waitUntil(requestPromises); // If a MessageChannel was used, reply to the message on success.\n\n          if (event.ports && event.ports[0]) {\n            requestPromises.then(function () {\n              return event.ports[0].postMessage(true);\n            });\n          }\n        }\n      });\n    }\n    /**\r\n     * Apply the routing rules to a FetchEvent object to get a Response from an\r\n     * appropriate Route's handler.\r\n     *\r\n     * @param {Object} options\r\n     * @param {Request} options.request The request to handle (this is usually\r\n     *     from a fetch event, but it does not have to be).\r\n     * @param {FetchEvent} [options.event] The event that triggered the request,\r\n     *     if applicable.\r\n     * @return {Promise<Response>|undefined} A promise is returned if a\r\n     *     registered route can handle the request. If there is no matching\r\n     *     route and there's no `defaultHandler`, `undefined` is returned.\r\n     */\n\n  }, {\n    key: \"handleRequest\",\n    value: function handleRequest(_ref) {\n      var _this3 = this;\n\n      var request = _ref.request,\n          event = _ref.event;\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isInstance(request, Request, {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'handleRequest',\n          paramName: 'options.request'\n        });\n      }\n\n      var url = new URL(request.url, location.href);\n\n      if (!url.protocol.startsWith('http')) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(\"Workbox Router only supports URLs that start with 'http'.\");\n        }\n\n        return;\n      }\n\n      var _this$findMatchingRou = this.findMatchingRoute({\n        url: url,\n        request: request,\n        event: event\n      }),\n          params = _this$findMatchingRou.params,\n          route = _this$findMatchingRou.route;\n\n      var handler = route && route.handler;\n      var debugMessages = [];\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (handler) {\n          debugMessages.push([\"Found a route to handle this request:\", route]);\n\n          if (params) {\n            debugMessages.push([\"Passing the following params to the route's handler:\", params]);\n          }\n        }\n      } // If we don't have a handler because there was no matching route, then\n      // fall back to defaultHandler if that's defined.\n\n\n      if (!handler && this._defaultHandler) {\n        if (process.env.NODE_ENV !== 'production') {\n          debugMessages.push(\"Failed to find a matching route. Falling \" + \"back to the default handler.\");\n        }\n\n        handler = this._defaultHandler;\n      }\n\n      if (!handler) {\n        if (process.env.NODE_ENV !== 'production') {\n          // No handler so Workbox will do nothing. If logs is set of debug\n          // i.e. verbose, we should print out this information.\n          logger.debug(\"No route found for: \".concat(getFriendlyURL(url)));\n        }\n\n        return;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        // We have a handler, meaning Workbox is going to handle the route.\n        // print the routing details to the console.\n        logger.groupCollapsed(\"Router is responding to: \".concat(getFriendlyURL(url)));\n        debugMessages.forEach(function (msg) {\n          if (Array.isArray(msg)) {\n            logger.log.apply(logger, _toConsumableArray(msg));\n          } else {\n            logger.log(msg);\n          }\n        });\n        logger.groupEnd();\n      } // Wrap in try and catch in case the handle method throws a synchronous\n      // error. It should still callback to the catch handler.\n\n\n      var responsePromise;\n\n      try {\n        responsePromise = handler.handle({\n          url: url,\n          request: request,\n          event: event,\n          params: params\n        });\n      } catch (err) {\n        responsePromise = Promise.reject(err);\n      }\n\n      if (responsePromise instanceof Promise && this._catchHandler) {\n        responsePromise = responsePromise.catch(function (err) {\n          if (process.env.NODE_ENV !== 'production') {\n            // Still include URL here as it will be async from the console group\n            // and may not make sense without the URL\n            logger.groupCollapsed(\"Error thrown when responding to: \" + \" \".concat(getFriendlyURL(url), \". Falling back to Catch Handler.\"));\n            logger.error(\"Error thrown by:\", route);\n            logger.error(err);\n            logger.groupEnd();\n          }\n\n          return _this3._catchHandler.handle({\n            url: url,\n            request: request,\n            event: event\n          });\n        });\n      }\n\n      return responsePromise;\n    }\n    /**\r\n     * Checks a request and URL (and optionally an event) against the list of\r\n     * registered routes, and if there's a match, returns the corresponding\r\n     * route along with any params generated by the match.\r\n     *\r\n     * @param {Object} options\r\n     * @param {URL} options.url\r\n     * @param {Request} options.request The request to match.\r\n     * @param {Event} [options.event] The corresponding event (unless N/A).\r\n     * @return {Object} An object with `route` and `params` properties.\r\n     *     They are populated if a matching route was found or `undefined`\r\n     *     otherwise.\r\n     */\n\n  }, {\n    key: \"findMatchingRoute\",\n    value: function findMatchingRoute(_ref2) {\n      var url = _ref2.url,\n          request = _ref2.request,\n          event = _ref2.event;\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isInstance(url, URL, {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'findMatchingRoute',\n          paramName: 'options.url'\n        });\n        assert.isInstance(request, Request, {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'findMatchingRoute',\n          paramName: 'options.request'\n        });\n      }\n\n      var routes = this._routes.get(request.method) || [];\n\n      var _iterator = _createForOfIteratorHelper(routes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var route = _step.value;\n          var params = void 0;\n          var matchResult = route.match({\n            url: url,\n            request: request,\n            event: event\n          });\n\n          if (matchResult) {\n            // See https://github.com/GoogleChrome/workbox/issues/2079\n            params = matchResult;\n\n            if (Array.isArray(matchResult) && matchResult.length === 0) {\n              // Instead of passing an empty array in as params, use undefined.\n              params = undefined;\n            } else if (matchResult.constructor === Object && Object.keys(matchResult).length === 0) {\n              // Instead of passing an empty object in as params, use undefined.\n              params = undefined;\n            } else if (typeof matchResult === 'boolean') {\n              // For the boolean value true (rather than just something truth-y),\n              // don't set params.\n              // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n              params = undefined;\n            } // Return early if have a match.\n\n\n            return {\n              route: route,\n              params: params\n            };\n          }\n        } // If no match was found above, return and empty object.\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return {};\n    }\n    /**\r\n     * Define a default `handler` that's called when no routes explicitly\r\n     * match the incoming request.\r\n     *\r\n     * Without a default handler, unmatched requests will go against the\r\n     * network as if there were no service worker present.\r\n     *\r\n     * @param {module:workbox-routing~handlerCallback} handler A callback\r\n     * function that returns a Promise resulting in a Response.\r\n     */\n\n  }, {\n    key: \"setDefaultHandler\",\n    value: function setDefaultHandler(handler) {\n      this._defaultHandler = normalizeHandler(handler);\n    }\n    /**\r\n     * If a Route throws an error while handling a request, this `handler`\r\n     * will be called and given a chance to provide a response.\r\n     *\r\n     * @param {module:workbox-routing~handlerCallback} handler A callback\r\n     * function that returns a Promise resulting in a Response.\r\n     */\n\n  }, {\n    key: \"setCatchHandler\",\n    value: function setCatchHandler(handler) {\n      this._catchHandler = normalizeHandler(handler);\n    }\n    /**\r\n     * Registers a route with the router.\r\n     *\r\n     * @param {module:workbox-routing.Route} route The route to register.\r\n     */\n\n  }, {\n    key: \"registerRoute\",\n    value: function registerRoute(route) {\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isType(route, 'object', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route'\n        });\n        assert.hasMethod(route, 'match', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route'\n        });\n        assert.isType(route.handler, 'object', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route'\n        });\n        assert.hasMethod(route.handler, 'handle', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route.handler'\n        });\n        assert.isType(route.method, 'string', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route.method'\n        });\n      }\n\n      if (!this._routes.has(route.method)) {\n        this._routes.set(route.method, []);\n      } // Give precedence to all of the earlier routes by adding this additional\n      // route to the end of the array.\n\n\n      this._routes.get(route.method).push(route);\n    }\n    /**\r\n     * Unregisters a route with the router.\r\n     *\r\n     * @param {module:workbox-routing.Route} route The route to unregister.\r\n     */\n\n  }, {\n    key: \"unregisterRoute\",\n    value: function unregisterRoute(route) {\n      if (!this._routes.has(route.method)) {\n        throw new WorkboxError('unregister-route-but-not-found-with-method', {\n          method: route.method\n        });\n      }\n\n      var routeIndex = this._routes.get(route.method).indexOf(route);\n\n      if (routeIndex > -1) {\n        this._routes.get(route.method).splice(routeIndex, 1);\n      } else {\n        throw new WorkboxError('unregister-route-route-not-registered');\n      }\n    }\n  }]);\n\n  return Router;\n}();\n\nexport { Router };","map":{"version":3,"sources":["C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/workbox-routing/Router.js"],"names":["assert","logger","WorkboxError","getFriendlyURL","normalizeHandler","Router","_routes","Map","self","addEventListener","event","request","responsePromise","handleRequest","respondWith","data","type","payload","process","env","NODE_ENV","debug","urlsToCache","requestPromises","Promise","all","map","entry","Request","waitUntil","ports","then","postMessage","isInstance","moduleName","className","funcName","paramName","url","URL","location","href","protocol","startsWith","findMatchingRoute","params","route","handler","debugMessages","push","_defaultHandler","groupCollapsed","forEach","msg","Array","isArray","log","groupEnd","handle","err","reject","_catchHandler","catch","error","routes","get","method","matchResult","match","length","undefined","constructor","Object","keys","isType","hasMethod","has","set","routeIndex","indexOf","splice"],"mappings":"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","sourcesContent":["/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { assert } from 'workbox-core/_private/assert.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\r\nimport { normalizeHandler } from './utils/normalizeHandler.js';\r\nimport './_version.js';\r\n/**\r\n * The Router can be used to process a FetchEvent through one or more\r\n * [Routes]{@link module:workbox-routing.Route} responding  with a Request if\r\n * a matching route exists.\r\n *\r\n * If no route matches a given a request, the Router will use a \"default\"\r\n * handler if one is defined.\r\n *\r\n * Should the matching Route throw an error, the Router will use a \"catch\"\r\n * handler if one is defined to gracefully deal with issues and respond with a\r\n * Request.\r\n *\r\n * If a request matches multiple routes, the **earliest** registered route will\r\n * be used to respond to the request.\r\n *\r\n * @memberof module:workbox-routing\r\n */\r\nclass Router {\r\n    /**\r\n     * Initializes a new Router.\r\n     */\r\n    constructor() {\r\n        this._routes = new Map();\r\n    }\r\n    /**\r\n     * @return {Map<string, Array<module:workbox-routing.Route>>} routes A `Map` of HTTP\r\n     * method name ('GET', etc.) to an array of all the corresponding `Route`\r\n     * instances that are registered.\r\n     */\r\n    get routes() {\r\n        return this._routes;\r\n    }\r\n    /**\r\n     * Adds a fetch event listener to respond to events when a route matches\r\n     * the event's request.\r\n     */\r\n    addFetchListener() {\r\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\r\n        self.addEventListener('fetch', ((event) => {\r\n            const { request } = event;\r\n            const responsePromise = this.handleRequest({ request, event });\r\n            if (responsePromise) {\r\n                event.respondWith(responsePromise);\r\n            }\r\n        }));\r\n    }\r\n    /**\r\n     * Adds a message event listener for URLs to cache from the window.\r\n     * This is useful to cache resources loaded on the page prior to when the\r\n     * service worker started controlling it.\r\n     *\r\n     * The format of the message data sent from the window should be as follows.\r\n     * Where the `urlsToCache` array may consist of URL strings or an array of\r\n     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\r\n     *\r\n     * ```\r\n     * {\r\n     *   type: 'CACHE_URLS',\r\n     *   payload: {\r\n     *     urlsToCache: [\r\n     *       './script1.js',\r\n     *       './script2.js',\r\n     *       ['./script3.js', {mode: 'no-cors'}],\r\n     *     ],\r\n     *   },\r\n     * }\r\n     * ```\r\n     */\r\n    addCacheListener() {\r\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\r\n        self.addEventListener('message', ((event) => {\r\n            if (event.data && event.data.type === 'CACHE_URLS') {\r\n                const { payload } = event.data;\r\n                if (process.env.NODE_ENV !== 'production') {\r\n                    logger.debug(`Caching URLs from the window`, payload.urlsToCache);\r\n                }\r\n                const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {\r\n                    if (typeof entry === 'string') {\r\n                        entry = [entry];\r\n                    }\r\n                    const request = new Request(...entry);\r\n                    return this.handleRequest({ request });\r\n                    // TODO(philipwalton): TypeScript errors without this typecast for\r\n                    // some reason (probably a bug). The real type here should work but\r\n                    // doesn't: `Array<Promise<Response> | undefined>`.\r\n                })); // TypeScript\r\n                event.waitUntil(requestPromises);\r\n                // If a MessageChannel was used, reply to the message on success.\r\n                if (event.ports && event.ports[0]) {\r\n                    requestPromises.then(() => event.ports[0].postMessage(true));\r\n                }\r\n            }\r\n        }));\r\n    }\r\n    /**\r\n     * Apply the routing rules to a FetchEvent object to get a Response from an\r\n     * appropriate Route's handler.\r\n     *\r\n     * @param {Object} options\r\n     * @param {Request} options.request The request to handle (this is usually\r\n     *     from a fetch event, but it does not have to be).\r\n     * @param {FetchEvent} [options.event] The event that triggered the request,\r\n     *     if applicable.\r\n     * @return {Promise<Response>|undefined} A promise is returned if a\r\n     *     registered route can handle the request. If there is no matching\r\n     *     route and there's no `defaultHandler`, `undefined` is returned.\r\n     */\r\n    handleRequest({ request, event }) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isInstance(request, Request, {\r\n                moduleName: 'workbox-routing',\r\n                className: 'Router',\r\n                funcName: 'handleRequest',\r\n                paramName: 'options.request',\r\n            });\r\n        }\r\n        const url = new URL(request.url, location.href);\r\n        if (!url.protocol.startsWith('http')) {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\r\n            }\r\n            return;\r\n        }\r\n        const { params, route } = this.findMatchingRoute({ url, request, event });\r\n        let handler = route && route.handler;\r\n        const debugMessages = [];\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (handler) {\r\n                debugMessages.push([\r\n                    `Found a route to handle this request:`, route,\r\n                ]);\r\n                if (params) {\r\n                    debugMessages.push([\r\n                        `Passing the following params to the route's handler:`, params,\r\n                    ]);\r\n                }\r\n            }\r\n        }\r\n        // If we don't have a handler because there was no matching route, then\r\n        // fall back to defaultHandler if that's defined.\r\n        if (!handler && this._defaultHandler) {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                debugMessages.push(`Failed to find a matching route. Falling ` +\r\n                    `back to the default handler.`);\r\n            }\r\n            handler = this._defaultHandler;\r\n        }\r\n        if (!handler) {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                // No handler so Workbox will do nothing. If logs is set of debug\r\n                // i.e. verbose, we should print out this information.\r\n                logger.debug(`No route found for: ${getFriendlyURL(url)}`);\r\n            }\r\n            return;\r\n        }\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            // We have a handler, meaning Workbox is going to handle the route.\r\n            // print the routing details to the console.\r\n            logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\r\n            debugMessages.forEach((msg) => {\r\n                if (Array.isArray(msg)) {\r\n                    logger.log(...msg);\r\n                }\r\n                else {\r\n                    logger.log(msg);\r\n                }\r\n            });\r\n            logger.groupEnd();\r\n        }\r\n        // Wrap in try and catch in case the handle method throws a synchronous\r\n        // error. It should still callback to the catch handler.\r\n        let responsePromise;\r\n        try {\r\n            responsePromise = handler.handle({ url, request, event, params });\r\n        }\r\n        catch (err) {\r\n            responsePromise = Promise.reject(err);\r\n        }\r\n        if (responsePromise instanceof Promise && this._catchHandler) {\r\n            responsePromise = responsePromise.catch((err) => {\r\n                if (process.env.NODE_ENV !== 'production') {\r\n                    // Still include URL here as it will be async from the console group\r\n                    // and may not make sense without the URL\r\n                    logger.groupCollapsed(`Error thrown when responding to: ` +\r\n                        ` ${getFriendlyURL(url)}. Falling back to Catch Handler.`);\r\n                    logger.error(`Error thrown by:`, route);\r\n                    logger.error(err);\r\n                    logger.groupEnd();\r\n                }\r\n                return this._catchHandler.handle({ url, request, event });\r\n            });\r\n        }\r\n        return responsePromise;\r\n    }\r\n    /**\r\n     * Checks a request and URL (and optionally an event) against the list of\r\n     * registered routes, and if there's a match, returns the corresponding\r\n     * route along with any params generated by the match.\r\n     *\r\n     * @param {Object} options\r\n     * @param {URL} options.url\r\n     * @param {Request} options.request The request to match.\r\n     * @param {Event} [options.event] The corresponding event (unless N/A).\r\n     * @return {Object} An object with `route` and `params` properties.\r\n     *     They are populated if a matching route was found or `undefined`\r\n     *     otherwise.\r\n     */\r\n    findMatchingRoute({ url, request, event }) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isInstance(url, URL, {\r\n                moduleName: 'workbox-routing',\r\n                className: 'Router',\r\n                funcName: 'findMatchingRoute',\r\n                paramName: 'options.url',\r\n            });\r\n            assert.isInstance(request, Request, {\r\n                moduleName: 'workbox-routing',\r\n                className: 'Router',\r\n                funcName: 'findMatchingRoute',\r\n                paramName: 'options.request',\r\n            });\r\n        }\r\n        const routes = this._routes.get(request.method) || [];\r\n        for (const route of routes) {\r\n            let params;\r\n            const matchResult = route.match({ url, request, event });\r\n            if (matchResult) {\r\n                // See https://github.com/GoogleChrome/workbox/issues/2079\r\n                params = matchResult;\r\n                if (Array.isArray(matchResult) && matchResult.length === 0) {\r\n                    // Instead of passing an empty array in as params, use undefined.\r\n                    params = undefined;\r\n                }\r\n                else if ((matchResult.constructor === Object &&\r\n                    Object.keys(matchResult).length === 0)) {\r\n                    // Instead of passing an empty object in as params, use undefined.\r\n                    params = undefined;\r\n                }\r\n                else if (typeof matchResult === 'boolean') {\r\n                    // For the boolean value true (rather than just something truth-y),\r\n                    // don't set params.\r\n                    // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\r\n                    params = undefined;\r\n                }\r\n                // Return early if have a match.\r\n                return { route, params };\r\n            }\r\n        }\r\n        // If no match was found above, return and empty object.\r\n        return {};\r\n    }\r\n    /**\r\n     * Define a default `handler` that's called when no routes explicitly\r\n     * match the incoming request.\r\n     *\r\n     * Without a default handler, unmatched requests will go against the\r\n     * network as if there were no service worker present.\r\n     *\r\n     * @param {module:workbox-routing~handlerCallback} handler A callback\r\n     * function that returns a Promise resulting in a Response.\r\n     */\r\n    setDefaultHandler(handler) {\r\n        this._defaultHandler = normalizeHandler(handler);\r\n    }\r\n    /**\r\n     * If a Route throws an error while handling a request, this `handler`\r\n     * will be called and given a chance to provide a response.\r\n     *\r\n     * @param {module:workbox-routing~handlerCallback} handler A callback\r\n     * function that returns a Promise resulting in a Response.\r\n     */\r\n    setCatchHandler(handler) {\r\n        this._catchHandler = normalizeHandler(handler);\r\n    }\r\n    /**\r\n     * Registers a route with the router.\r\n     *\r\n     * @param {module:workbox-routing.Route} route The route to register.\r\n     */\r\n    registerRoute(route) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isType(route, 'object', {\r\n                moduleName: 'workbox-routing',\r\n                className: 'Router',\r\n                funcName: 'registerRoute',\r\n                paramName: 'route',\r\n            });\r\n            assert.hasMethod(route, 'match', {\r\n                moduleName: 'workbox-routing',\r\n                className: 'Router',\r\n                funcName: 'registerRoute',\r\n                paramName: 'route',\r\n            });\r\n            assert.isType(route.handler, 'object', {\r\n                moduleName: 'workbox-routing',\r\n                className: 'Router',\r\n                funcName: 'registerRoute',\r\n                paramName: 'route',\r\n            });\r\n            assert.hasMethod(route.handler, 'handle', {\r\n                moduleName: 'workbox-routing',\r\n                className: 'Router',\r\n                funcName: 'registerRoute',\r\n                paramName: 'route.handler',\r\n            });\r\n            assert.isType(route.method, 'string', {\r\n                moduleName: 'workbox-routing',\r\n                className: 'Router',\r\n                funcName: 'registerRoute',\r\n                paramName: 'route.method',\r\n            });\r\n        }\r\n        if (!this._routes.has(route.method)) {\r\n            this._routes.set(route.method, []);\r\n        }\r\n        // Give precedence to all of the earlier routes by adding this additional\r\n        // route to the end of the array.\r\n        this._routes.get(route.method).push(route);\r\n    }\r\n    /**\r\n     * Unregisters a route with the router.\r\n     *\r\n     * @param {module:workbox-routing.Route} route The route to unregister.\r\n     */\r\n    unregisterRoute(route) {\r\n        if (!this._routes.has(route.method)) {\r\n            throw new WorkboxError('unregister-route-but-not-found-with-method', {\r\n                method: route.method,\r\n            });\r\n        }\r\n        const routeIndex = this._routes.get(route.method).indexOf(route);\r\n        if (routeIndex > -1) {\r\n            this._routes.get(route.method).splice(routeIndex, 1);\r\n        }\r\n        else {\r\n            throw new WorkboxError('unregister-route-route-not-registered');\r\n        }\r\n    }\r\n}\r\nexport { Router };\r\n"]},"metadata":{},"sourceType":"module"}