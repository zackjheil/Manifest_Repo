{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _createForOfIteratorHelper from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.js';\nimport './_version.js';\n/**\r\n * The `CacheExpiration` class allows you define an expiration and / or\r\n * limit on the number of responses stored in a\r\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\r\n *\r\n * @memberof module:workbox-expiration\r\n */\n\nvar CacheExpiration = /*#__PURE__*/function () {\n  /**\r\n   * To construct a new CacheExpiration instance you must provide at least\r\n   * one of the `config` properties.\r\n   *\r\n   * @param {string} cacheName Name of the cache to apply restrictions to.\r\n   * @param {Object} config\r\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\r\n   * Entries used the least will be removed as the maximum is reached.\r\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\r\n   * it's treated as stale and removed.\r\n   */\n  function CacheExpiration(cacheName) {\n    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, CacheExpiration);\n\n    this._isRunning = false;\n    this._rerunRequested = false;\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'constructor',\n        paramName: 'cacheName'\n      });\n\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor'\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries'\n        }); // TODO: Assert is positive\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds'\n        }); // TODO: Assert is positive\n      }\n    }\n\n    this._maxEntries = config.maxEntries;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheName = cacheName;\n    this._timestampModel = new CacheTimestampsModel(cacheName);\n  }\n  /**\r\n   * Expires entries for the given cache and given criteria.\r\n   */\n\n\n  _createClass(CacheExpiration, [{\n    key: \"expireEntries\",\n    value: function () {\n      var _expireEntries = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var minTimestamp, urlsExpired, cache, _iterator, _step, url;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._isRunning) {\n                  _context.next = 3;\n                  break;\n                }\n\n                this._rerunRequested = true;\n                return _context.abrupt(\"return\");\n\n              case 3:\n                this._isRunning = true;\n                minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : 0;\n                _context.next = 7;\n                return this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n\n              case 7:\n                urlsExpired = _context.sent;\n                _context.next = 10;\n                return self.caches.open(this._cacheName);\n\n              case 10:\n                cache = _context.sent;\n                _iterator = _createForOfIteratorHelper(urlsExpired);\n                _context.prev = 12;\n\n                _iterator.s();\n\n              case 14:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 20;\n                  break;\n                }\n\n                url = _step.value;\n                _context.next = 18;\n                return cache.delete(url);\n\n              case 18:\n                _context.next = 14;\n                break;\n\n              case 20:\n                _context.next = 25;\n                break;\n\n              case 22:\n                _context.prev = 22;\n                _context.t0 = _context[\"catch\"](12);\n\n                _iterator.e(_context.t0);\n\n              case 25:\n                _context.prev = 25;\n\n                _iterator.f();\n\n                return _context.finish(25);\n\n              case 28:\n                if (process.env.NODE_ENV !== 'production') {\n                  if (urlsExpired.length > 0) {\n                    logger.groupCollapsed(\"Expired \".concat(urlsExpired.length, \" \") + \"\".concat(urlsExpired.length === 1 ? 'entry' : 'entries', \" and removed \") + \"\".concat(urlsExpired.length === 1 ? 'it' : 'them', \" from the \") + \"'\".concat(this._cacheName, \"' cache.\"));\n                    logger.log(\"Expired the following \".concat(urlsExpired.length === 1 ? 'URL' : 'URLs', \":\"));\n                    urlsExpired.forEach(function (url) {\n                      return logger.log(\"    \".concat(url));\n                    });\n                    logger.groupEnd();\n                  } else {\n                    logger.debug(\"Cache expiration ran and found no entries to remove.\");\n                  }\n                }\n\n                this._isRunning = false;\n\n                if (this._rerunRequested) {\n                  this._rerunRequested = false;\n                  dontWaitFor(this.expireEntries());\n                }\n\n              case 31:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[12, 22, 25, 28]]);\n      }));\n\n      function expireEntries() {\n        return _expireEntries.apply(this, arguments);\n      }\n\n      return expireEntries;\n    }()\n    /**\r\n     * Update the timestamp for the given URL. This ensures the when\r\n     * removing entries based on maximum entries, most recently used\r\n     * is accurate or when expiring, the timestamp is up-to-date.\r\n     *\r\n     * @param {string} url\r\n     */\n\n  }, {\n    key: \"updateTimestamp\",\n    value: function () {\n      var _updateTimestamp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(url) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (process.env.NODE_ENV !== 'production') {\n                  assert.isType(url, 'string', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'updateTimestamp',\n                    paramName: 'url'\n                  });\n                }\n\n                _context2.next = 3;\n                return this._timestampModel.setTimestamp(url, Date.now());\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function updateTimestamp(_x) {\n        return _updateTimestamp.apply(this, arguments);\n      }\n\n      return updateTimestamp;\n    }()\n    /**\r\n     * Can be used to check if a URL has expired or not before it's used.\r\n     *\r\n     * This requires a look up from IndexedDB, so can be slow.\r\n     *\r\n     * Note: This method will not remove the cached entry, call\r\n     * `expireEntries()` to remove indexedDB and Cache entries.\r\n     *\r\n     * @param {string} url\r\n     * @return {boolean}\r\n     */\n\n  }, {\n    key: \"isURLExpired\",\n    value: function () {\n      var _isURLExpired = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(url) {\n        var timestamp, expireOlderThan;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (this._maxAgeSeconds) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                if (!(process.env.NODE_ENV !== 'production')) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                throw new WorkboxError(\"expired-test-without-max-age\", {\n                  methodName: 'isURLExpired',\n                  paramName: 'maxAgeSeconds'\n                });\n\n              case 3:\n                return _context3.abrupt(\"return\", false);\n\n              case 6:\n                _context3.next = 8;\n                return this._timestampModel.getTimestamp(url);\n\n              case 8:\n                timestamp = _context3.sent;\n                expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n                return _context3.abrupt(\"return\", timestamp < expireOlderThan);\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function isURLExpired(_x2) {\n        return _isURLExpired.apply(this, arguments);\n      }\n\n      return isURLExpired;\n    }()\n    /**\r\n     * Removes the IndexedDB object store used to keep track of cache expiration\r\n     * metadata.\r\n     */\n\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                // Make sure we don't attempt another rerun if we're called in the middle of\n                // a cache expiration.\n                this._rerunRequested = false;\n                _context4.next = 3;\n                return this._timestampModel.expireEntries(Infinity);\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _delete() {\n        return _delete2.apply(this, arguments);\n      }\n\n      return _delete;\n    }()\n  }]);\n\n  return CacheExpiration;\n}();\n\nexport { CacheExpiration };","map":{"version":3,"sources":["C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/workbox-expiration/CacheExpiration.js"],"names":["assert","dontWaitFor","logger","WorkboxError","CacheTimestampsModel","CacheExpiration","cacheName","config","_isRunning","_rerunRequested","process","env","NODE_ENV","isType","moduleName","className","funcName","paramName","maxEntries","maxAgeSeconds","_maxEntries","_maxAgeSeconds","_cacheName","_timestampModel","minTimestamp","Date","now","expireEntries","urlsExpired","self","caches","open","cache","url","delete","length","groupCollapsed","log","forEach","groupEnd","debug","setTimestamp","methodName","getTimestamp","timestamp","expireOlderThan","Infinity"],"mappings":"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","sourcesContent":["/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { assert } from 'workbox-core/_private/assert.js';\r\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.js';\r\nimport './_version.js';\r\n/**\r\n * The `CacheExpiration` class allows you define an expiration and / or\r\n * limit on the number of responses stored in a\r\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\r\n *\r\n * @memberof module:workbox-expiration\r\n */\r\nclass CacheExpiration {\r\n    /**\r\n     * To construct a new CacheExpiration instance you must provide at least\r\n     * one of the `config` properties.\r\n     *\r\n     * @param {string} cacheName Name of the cache to apply restrictions to.\r\n     * @param {Object} config\r\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\r\n     * Entries used the least will be removed as the maximum is reached.\r\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\r\n     * it's treated as stale and removed.\r\n     */\r\n    constructor(cacheName, config = {}) {\r\n        this._isRunning = false;\r\n        this._rerunRequested = false;\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isType(cacheName, 'string', {\r\n                moduleName: 'workbox-expiration',\r\n                className: 'CacheExpiration',\r\n                funcName: 'constructor',\r\n                paramName: 'cacheName',\r\n            });\r\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\r\n                throw new WorkboxError('max-entries-or-age-required', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'CacheExpiration',\r\n                    funcName: 'constructor',\r\n                });\r\n            }\r\n            if (config.maxEntries) {\r\n                assert.isType(config.maxEntries, 'number', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'CacheExpiration',\r\n                    funcName: 'constructor',\r\n                    paramName: 'config.maxEntries',\r\n                });\r\n                // TODO: Assert is positive\r\n            }\r\n            if (config.maxAgeSeconds) {\r\n                assert.isType(config.maxAgeSeconds, 'number', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'CacheExpiration',\r\n                    funcName: 'constructor',\r\n                    paramName: 'config.maxAgeSeconds',\r\n                });\r\n                // TODO: Assert is positive\r\n            }\r\n        }\r\n        this._maxEntries = config.maxEntries;\r\n        this._maxAgeSeconds = config.maxAgeSeconds;\r\n        this._cacheName = cacheName;\r\n        this._timestampModel = new CacheTimestampsModel(cacheName);\r\n    }\r\n    /**\r\n     * Expires entries for the given cache and given criteria.\r\n     */\r\n    async expireEntries() {\r\n        if (this._isRunning) {\r\n            this._rerunRequested = true;\r\n            return;\r\n        }\r\n        this._isRunning = true;\r\n        const minTimestamp = this._maxAgeSeconds ?\r\n            Date.now() - (this._maxAgeSeconds * 1000) : 0;\r\n        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\r\n        // Delete URLs from the cache\r\n        const cache = await self.caches.open(this._cacheName);\r\n        for (const url of urlsExpired) {\r\n            await cache.delete(url);\r\n        }\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (urlsExpired.length > 0) {\r\n                logger.groupCollapsed(`Expired ${urlsExpired.length} ` +\r\n                    `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\r\n                    `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\r\n                    `'${this._cacheName}' cache.`);\r\n                logger.log(`Expired the following ${urlsExpired.length === 1 ?\r\n                    'URL' : 'URLs'}:`);\r\n                urlsExpired.forEach((url) => logger.log(`    ${url}`));\r\n                logger.groupEnd();\r\n            }\r\n            else {\r\n                logger.debug(`Cache expiration ran and found no entries to remove.`);\r\n            }\r\n        }\r\n        this._isRunning = false;\r\n        if (this._rerunRequested) {\r\n            this._rerunRequested = false;\r\n            dontWaitFor(this.expireEntries());\r\n        }\r\n    }\r\n    /**\r\n     * Update the timestamp for the given URL. This ensures the when\r\n     * removing entries based on maximum entries, most recently used\r\n     * is accurate or when expiring, the timestamp is up-to-date.\r\n     *\r\n     * @param {string} url\r\n     */\r\n    async updateTimestamp(url) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isType(url, 'string', {\r\n                moduleName: 'workbox-expiration',\r\n                className: 'CacheExpiration',\r\n                funcName: 'updateTimestamp',\r\n                paramName: 'url',\r\n            });\r\n        }\r\n        await this._timestampModel.setTimestamp(url, Date.now());\r\n    }\r\n    /**\r\n     * Can be used to check if a URL has expired or not before it's used.\r\n     *\r\n     * This requires a look up from IndexedDB, so can be slow.\r\n     *\r\n     * Note: This method will not remove the cached entry, call\r\n     * `expireEntries()` to remove indexedDB and Cache entries.\r\n     *\r\n     * @param {string} url\r\n     * @return {boolean}\r\n     */\r\n    async isURLExpired(url) {\r\n        if (!this._maxAgeSeconds) {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                throw new WorkboxError(`expired-test-without-max-age`, {\r\n                    methodName: 'isURLExpired',\r\n                    paramName: 'maxAgeSeconds',\r\n                });\r\n            }\r\n            return false;\r\n        }\r\n        else {\r\n            const timestamp = await this._timestampModel.getTimestamp(url);\r\n            const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);\r\n            return (timestamp < expireOlderThan);\r\n        }\r\n    }\r\n    /**\r\n     * Removes the IndexedDB object store used to keep track of cache expiration\r\n     * metadata.\r\n     */\r\n    async delete() {\r\n        // Make sure we don't attempt another rerun if we're called in the middle of\r\n        // a cache expiration.\r\n        this._rerunRequested = false;\r\n        await this._timestampModel.expireEntries(Infinity); // Expires all.\r\n    }\r\n}\r\nexport { CacheExpiration };\r\n"]},"metadata":{},"sourceType":"module"}