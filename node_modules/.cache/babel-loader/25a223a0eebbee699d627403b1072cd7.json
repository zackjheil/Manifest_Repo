{"ast":null,"code":"import isSubset from '../../utils/isSubset';\nimport logger from \"../../utils/logger\";\nimport selectionLevel from '../../api-utils/selectionLevel';\nimport success from '../../api-utils/success';\nimport error from '../../api-utils/error';\nimport showUserErrors from '../../api-utils/showUserErrors';\nexport default function deleteIt() {\n  return new Promise((resolve, reject) => {\n    // delete database\n    this.deleteDatabase = () => {\n      let dbName = this.dbName;\n      indexedDB.deleteDatabase(dbName);\n      resolve(success.call(this, `Database \"${dbName}\" deleted.`));\n    }; // delete collection\n\n\n    this.deleteCollection = () => {\n      let dbName = this.dbName;\n      let collectionName = this.collectionName; // we can only delete one collection at a time, which is why we need a queue\n\n      this.addToDeleteCollectionQueue = collectionName => {\n        this.deleteCollectionQueue.queue.push(collectionName);\n        this.runDeleteCollectionQueue();\n      };\n\n      this.runDeleteCollectionQueue = () => {\n        if (this.deleteCollectionQueue.running == false) {\n          this.deleteCollectionQueue.running = true;\n          this.deleteNextCollectionFromQueue();\n        }\n      };\n\n      this.deleteNextCollectionFromQueue = () => {\n        if (this.deleteCollectionQueue.queue.length) {\n          let collectionToDelete = this.deleteCollectionQueue.queue[0];\n          this.deleteCollectionQueue.queue.shift();\n          this.lf[collectionToDelete].dropInstance({\n            name: dbName,\n            storeName: collectionToDelete\n          }).then(() => {\n            this.deleteNextCollectionFromQueue();\n            resolve(success.call(this, `Collection \"${collectionToDelete}\" deleted.`));\n          }).catch(error => {\n            reject(error.call(this, `Collection \"${collectionToDelete}\" could not be deleted.`));\n          });\n        } else {\n          this.deleteCollectionQueue.running = false;\n        }\n      };\n\n      this.addToDeleteCollectionQueue(collectionName);\n    }; // delete document\n\n\n    this.deleteDocument = () => {\n      let collectionName = this.collectionName;\n      let docSelectionCriteria = this.docSelectionCriteria; // delete document by criteria\n\n      this.deleteDocumentByCriteria = () => {\n        let keysForDeletion = [];\n        this.lf[collectionName].iterate((value, key) => {\n          if (isSubset(value, docSelectionCriteria)) {\n            keysForDeletion.push(key);\n          }\n        }).then(() => {\n          if (!keysForDeletion.length) {\n            reject(error.call(this, `No Documents found in \"${collectionName}\" Collection with criteria ${JSON.stringify(docSelectionCriteria)}. No documents deleted.`));\n          }\n\n          if (keysForDeletion.length > 1) {\n            logger.warn.call(this, `Multiple documents (${keysForDeletion.length}) with ${JSON.stringify(docSelectionCriteria)} found.`);\n          }\n        }).then(() => {\n          keysForDeletion.forEach((key, index) => {\n            this.lf[collectionName].removeItem(key).then(() => {\n              if (index === keysForDeletion.length - 1) {\n                resolve(success.call(this, `${keysForDeletion.length} Document${keysForDeletion.length > 1 ? 's' : ''} with ${JSON.stringify(docSelectionCriteria)} deleted.`));\n              }\n            }).catch(err => {\n              reject(error.call(this, `Could not delete ${keysForDeletion.length} Documents in ${collectionName} Collection.`));\n            });\n          });\n        });\n      }; // delete document by key\n\n\n      this.deleteDocumentByKey = () => {\n        this.lf[collectionName].getItem(docSelectionCriteria).then(value => {\n          if (value) {\n            this.lf[collectionName].removeItem(docSelectionCriteria).then(() => {\n              resolve(success.call(this, `Document with key ${JSON.stringify(docSelectionCriteria)} deleted.`));\n            }).catch(function (err) {\n              reject(error.call(this, `No Document found in \"${collectionName}\" Collection with key ${JSON.stringify(docSelectionCriteria)}. No document was deleted.`));\n            });\n          } else {\n            reject(error.call(this, `No Document found in \"${collectionName}\" Collection with key ${JSON.stringify(docSelectionCriteria)}. No document was deleted.`));\n          }\n        });\n      };\n\n      if (typeof docSelectionCriteria == 'object') {\n        return this.deleteDocumentByCriteria();\n      } else {\n        return this.deleteDocumentByKey();\n      }\n    };\n\n    if (!this.userErrors.length) {\n      let currentSelectionLevel = selectionLevel.call(this);\n\n      if (currentSelectionLevel == 'db') {\n        return this.deleteDatabase();\n      } else if (currentSelectionLevel == 'collection') {\n        return this.deleteCollection();\n      } else if (currentSelectionLevel == 'doc') {\n        return this.deleteDocument();\n      }\n    } else {\n      showUserErrors.call(this);\n    }\n  });\n}","map":{"version":3,"sources":["C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/localbase/localbase/api/actions/delete.js"],"names":["isSubset","logger","selectionLevel","success","error","showUserErrors","deleteIt","Promise","resolve","reject","deleteDatabase","dbName","indexedDB","call","deleteCollection","collectionName","addToDeleteCollectionQueue","deleteCollectionQueue","queue","push","runDeleteCollectionQueue","running","deleteNextCollectionFromQueue","length","collectionToDelete","shift","lf","dropInstance","name","storeName","then","catch","deleteDocument","docSelectionCriteria","deleteDocumentByCriteria","keysForDeletion","iterate","value","key","JSON","stringify","warn","forEach","index","removeItem","err","deleteDocumentByKey","getItem","userErrors","currentSelectionLevel"],"mappings":"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","sourcesContent":["import isSubset from '../../utils/isSubset'\r\nimport logger from \"../../utils/logger\"\r\nimport selectionLevel from '../../api-utils/selectionLevel'\r\nimport success from '../../api-utils/success'\r\nimport error from '../../api-utils/error'\r\nimport showUserErrors from '../../api-utils/showUserErrors'\r\n\r\nexport default function deleteIt() {\r\n\r\n  return new Promise((resolve, reject) => {\r\n\r\n    // delete database\r\n    this.deleteDatabase = () => {\r\n      let dbName = this.dbName\r\n\r\n      indexedDB.deleteDatabase(dbName)\r\n      resolve(\r\n        success.call(\r\n          this,\r\n          `Database \"${ dbName }\" deleted.`\r\n        )\r\n      )\r\n    }\r\n\r\n    // delete collection\r\n    this.deleteCollection = () => {\r\n      let dbName = this.dbName\r\n      let collectionName = this.collectionName\r\n\r\n      // we can only delete one collection at a time, which is why we need a queue\r\n\r\n      this.addToDeleteCollectionQueue = (collectionName) => {\r\n        this.deleteCollectionQueue.queue.push(collectionName)\r\n        this.runDeleteCollectionQueue()\r\n      }\r\n\r\n      this.runDeleteCollectionQueue = () => {\r\n        if (this.deleteCollectionQueue.running == false) {\r\n          this.deleteCollectionQueue.running = true\r\n          this.deleteNextCollectionFromQueue()\r\n        }\r\n      }\r\n\r\n      this.deleteNextCollectionFromQueue = () => {\r\n        if (this.deleteCollectionQueue.queue.length) {\r\n          let collectionToDelete = this.deleteCollectionQueue.queue[0]\r\n          this.deleteCollectionQueue.queue.shift()\r\n\r\n          this.lf[collectionToDelete].dropInstance({\r\n            name        : dbName,\r\n            storeName   : collectionToDelete\r\n          }).then(() => {\r\n            this.deleteNextCollectionFromQueue()\r\n            resolve(\r\n              success.call(\r\n                this,\r\n                `Collection \"${ collectionToDelete }\" deleted.`\r\n              )\r\n            )\r\n          }).catch(error => {\r\n            reject(\r\n              error.call(\r\n                this,\r\n                `Collection \"${ collectionToDelete }\" could not be deleted.`\r\n              )\r\n            )\r\n          })\r\n        }\r\n        else {\r\n          this.deleteCollectionQueue.running = false\r\n        }\r\n      }\r\n\r\n      this.addToDeleteCollectionQueue(collectionName)\r\n    }\r\n\r\n    // delete document\r\n    this.deleteDocument = () => {\r\n\r\n      let collectionName = this.collectionName\r\n      let docSelectionCriteria = this.docSelectionCriteria\r\n\r\n      // delete document by criteria\r\n      this.deleteDocumentByCriteria = () => {\r\n        let keysForDeletion = []\r\n        this.lf[collectionName].iterate((value, key) => {\r\n          if (isSubset(value, docSelectionCriteria)) {\r\n            keysForDeletion.push(key)\r\n          }\r\n        }).then(() => {\r\n          if (!keysForDeletion.length) {\r\n            reject(\r\n              error.call(\r\n                this,\r\n                `No Documents found in \"${ collectionName }\" Collection with criteria ${ JSON.stringify(docSelectionCriteria) }. No documents deleted.`\r\n              )\r\n            )\r\n          }\r\n          if (keysForDeletion.length > 1) {\r\n            logger.warn.call(this, `Multiple documents (${ keysForDeletion.length }) with ${ JSON.stringify(docSelectionCriteria) } found.`)\r\n          }\r\n        }).then(() => {\r\n          keysForDeletion.forEach((key, index) => {\r\n            this.lf[collectionName].removeItem(key).then(() => {\r\n              if (index === (keysForDeletion.length - 1)) {\r\n                resolve(\r\n                  success.call(\r\n                    this,\r\n                    `${ keysForDeletion.length } Document${ keysForDeletion.length > 1 ? 's' : '' } with ${ JSON.stringify(docSelectionCriteria) } deleted.`\r\n                  )\r\n                )\r\n              }\r\n            }).catch(err => {\r\n              reject(\r\n                error.call(\r\n                  this,\r\n                  `Could not delete ${ keysForDeletion.length } Documents in ${ collectionName } Collection.`\r\n                )\r\n              )\r\n            })\r\n          })\r\n        })\r\n      }\r\n\r\n      // delete document by key\r\n      this.deleteDocumentByKey = () => {\r\n        this.lf[collectionName].getItem(docSelectionCriteria).then(value => {\r\n          if (value) {\r\n            this.lf[collectionName].removeItem(docSelectionCriteria).then(() => {\r\n              resolve(\r\n                success.call(\r\n                  this,\r\n                  `Document with key ${ JSON.stringify(docSelectionCriteria) } deleted.`\r\n                )\r\n              )\r\n            }).catch(function(err) {\r\n              reject(\r\n                error.call(\r\n                  this,\r\n                  `No Document found in \"${ collectionName }\" Collection with key ${ JSON.stringify(docSelectionCriteria) }. No document was deleted.`\r\n                )\r\n              )\r\n            });\r\n          }\r\n          else {\r\n            reject(\r\n              error.call(\r\n                this,\r\n                `No Document found in \"${ collectionName }\" Collection with key ${ JSON.stringify(docSelectionCriteria) }. No document was deleted.`\r\n              )\r\n            )\r\n          }\r\n        });\r\n\r\n      }\r\n\r\n      if (typeof docSelectionCriteria == 'object') {\r\n        return this.deleteDocumentByCriteria()\r\n      }\r\n      else {\r\n        return this.deleteDocumentByKey()\r\n      }\r\n    }\r\n    \r\n    if (!this.userErrors.length) {\r\n      let currentSelectionLevel = selectionLevel.call(this)\r\n  \r\n      if (currentSelectionLevel == 'db') {\r\n        return this.deleteDatabase()\r\n      }\r\n      else if (currentSelectionLevel == 'collection') {\r\n        return this.deleteCollection()\r\n      }\r\n      else if (currentSelectionLevel == 'doc') {\r\n        return this.deleteDocument()\r\n      }\r\n    }\r\n    else {\r\n      showUserErrors.call(this)\r\n    }\r\n\r\n  })\r\n\r\n}"]},"metadata":{},"sourceType":"module"}