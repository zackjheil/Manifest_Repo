{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/*\r\n  Copyright 2019 Google LLC\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\nimport { timeout } from './timeout.js';\nimport '../_version.js';\nvar MAX_RETRY_TIME = 2000;\n/**\r\n * Returns a promise that resolves to a window client matching the passed\r\n * `resultingClientId`. For browsers that don't support `resultingClientId`\r\n * or if waiting for the resulting client to apper takes too long, resolve to\r\n * `undefined`.\r\n *\r\n * @param {string} [resultingClientId]\r\n * @return {Promise<Client|undefined>}\r\n * @private\r\n */\n\nexport function resultingClientExists(_x) {\n  return _resultingClientExists.apply(this, arguments);\n}\n\nfunction _resultingClientExists() {\n  _resultingClientExists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resultingClientId) {\n    var existingWindows, existingWindowIds, resultingWindow, startTime;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (resultingClientId) {\n              _context.next = 2;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 2:\n            _context.next = 4;\n            return self.clients.matchAll({\n              type: 'window'\n            });\n\n          case 4:\n            existingWindows = _context.sent;\n            existingWindowIds = new Set(existingWindows.map(function (w) {\n              return w.id;\n            }));\n            startTime = performance.now(); // Only wait up to `MAX_RETRY_TIME` to find a matching client.\n\n          case 7:\n            if (!(performance.now() - startTime < MAX_RETRY_TIME)) {\n              _context.next = 18;\n              break;\n            }\n\n            _context.next = 10;\n            return self.clients.matchAll({\n              type: 'window'\n            });\n\n          case 10:\n            existingWindows = _context.sent;\n            resultingWindow = existingWindows.find(function (w) {\n              if (resultingClientId) {\n                // If we have a `resultingClientId`, we can match on that.\n                return w.id === resultingClientId;\n              } else {\n                // Otherwise match on finding a window not in `existingWindowIds`.\n                return !existingWindowIds.has(w.id);\n              }\n            });\n\n            if (!resultingWindow) {\n              _context.next = 14;\n              break;\n            }\n\n            return _context.abrupt(\"break\", 18);\n\n          case 14:\n            _context.next = 16;\n            return timeout(100);\n\n          case 16:\n            _context.next = 7;\n            break;\n\n          case 18:\n            return _context.abrupt(\"return\", resultingWindow);\n\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _resultingClientExists.apply(this, arguments);\n}","map":{"version":3,"sources":["C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/workbox-core/_private/resultingClientExists.js"],"names":["timeout","MAX_RETRY_TIME","resultingClientExists","resultingClientId","self","clients","matchAll","type","existingWindows","existingWindowIds","Set","map","w","id","startTime","performance","now","resultingWindow","find","has"],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,OAAT,QAAwB,cAAxB;AACA,OAAO,gBAAP;AACA,IAAMC,cAAc,GAAG,IAAvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,gBAAsBC,qBAAtB;AAAA;AAAA;;;oFAAO,iBAAqCC,iBAArC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBACEA,iBADF;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA,mBAIyBC,IAAI,CAACC,OAAL,CAAaC,QAAb,CAAsB;AAAEC,cAAAA,IAAI,EAAE;AAAR,aAAtB,CAJzB;;AAAA;AAICC,YAAAA,eAJD;AAKGC,YAAAA,iBALH,GAKuB,IAAIC,GAAJ,CAAQF,eAAe,CAACG,GAAhB,CAAoB,UAACC,CAAD;AAAA,qBAAOA,CAAC,CAACC,EAAT;AAAA,aAApB,CAAR,CALvB;AAOGC,YAAAA,SAPH,GAOeC,WAAW,CAACC,GAAZ,EAPf,EAQH;;AARG;AAAA,kBASID,WAAW,CAACC,GAAZ,KAAoBF,SAApB,GAAgCb,cATpC;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAUyBG,IAAI,CAACC,OAAL,CAAaC,QAAb,CAAsB;AAAEC,cAAAA,IAAI,EAAE;AAAR,aAAtB,CAVzB;;AAAA;AAUCC,YAAAA,eAVD;AAWCS,YAAAA,eAAe,GAAGT,eAAe,CAACU,IAAhB,CAAqB,UAACN,CAAD,EAAO;AAC1C,kBAAIT,iBAAJ,EAAuB;AACnB;AACA,uBAAOS,CAAC,CAACC,EAAF,KAASV,iBAAhB;AACH,eAHD,MAIK;AACD;AACA,uBAAO,CAACM,iBAAiB,CAACU,GAAlB,CAAsBP,CAAC,CAACC,EAAxB,CAAR;AACH;AACJ,aATiB,CAAlB;;AAXD,iBAqBKI,eArBL;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA,mBAyBOjB,OAAO,CAAC,GAAD,CAzBd;;AAAA;AAAA;AAAA;;AAAA;AAAA,6CA2BIiB,eA3BJ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["/*\r\n  Copyright 2019 Google LLC\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { timeout } from './timeout.js';\r\nimport '../_version.js';\r\nconst MAX_RETRY_TIME = 2000;\r\n/**\r\n * Returns a promise that resolves to a window client matching the passed\r\n * `resultingClientId`. For browsers that don't support `resultingClientId`\r\n * or if waiting for the resulting client to apper takes too long, resolve to\r\n * `undefined`.\r\n *\r\n * @param {string} [resultingClientId]\r\n * @return {Promise<Client|undefined>}\r\n * @private\r\n */\r\nexport async function resultingClientExists(resultingClientId) {\r\n    if (!resultingClientId) {\r\n        return;\r\n    }\r\n    let existingWindows = await self.clients.matchAll({ type: 'window' });\r\n    const existingWindowIds = new Set(existingWindows.map((w) => w.id));\r\n    let resultingWindow;\r\n    const startTime = performance.now();\r\n    // Only wait up to `MAX_RETRY_TIME` to find a matching client.\r\n    while (performance.now() - startTime < MAX_RETRY_TIME) {\r\n        existingWindows = await self.clients.matchAll({ type: 'window' });\r\n        resultingWindow = existingWindows.find((w) => {\r\n            if (resultingClientId) {\r\n                // If we have a `resultingClientId`, we can match on that.\r\n                return w.id === resultingClientId;\r\n            }\r\n            else {\r\n                // Otherwise match on finding a window not in `existingWindowIds`.\r\n                return !existingWindowIds.has(w.id);\r\n            }\r\n        });\r\n        if (resultingWindow) {\r\n            break;\r\n        }\r\n        // Sleep for 100ms and retry.\r\n        await timeout(100);\r\n    }\r\n    return resultingWindow;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}