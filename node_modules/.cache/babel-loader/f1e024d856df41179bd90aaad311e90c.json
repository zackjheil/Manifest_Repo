{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { Route } from './Route.js';\nimport './_version.js';\n/**\r\n * NavigationRoute makes it easy to create a\r\n * [Route]{@link module:workbox-routing.Route} that matches for browser\r\n * [navigation requests]{@link https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading#first_what_are_navigation_requests}.\r\n *\r\n * It will only match incoming Requests whose\r\n * [`mode`]{@link https://fetch.spec.whatwg.org/#concept-request-mode}\r\n * is set to `navigate`.\r\n *\r\n * You can optionally only apply this route to a subset of navigation requests\r\n * by using one or both of the `denylist` and `allowlist` parameters.\r\n *\r\n * @memberof module:workbox-routing\r\n * @extends module:workbox-routing.Route\r\n */\n\nvar NavigationRoute = /*#__PURE__*/function (_Route) {\n  _inherits(NavigationRoute, _Route);\n\n  var _super = _createSuper(NavigationRoute);\n\n  /**\r\n   * If both `denylist` and `allowlist` are provided, the `denylist` will\r\n   * take precedence and the request will not match this route.\r\n   *\r\n   * The regular expressions in `allowlist` and `denylist`\r\n   * are matched against the concatenated\r\n   * [`pathname`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname}\r\n   * and [`search`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search}\r\n   * portions of the requested URL.\r\n   *\r\n   * @param {module:workbox-routing~handlerCallback} handler A callback\r\n   * function that returns a Promise resulting in a Response.\r\n   * @param {Object} options\r\n   * @param {Array<RegExp>} [options.denylist] If any of these patterns match,\r\n   * the route will not handle the request (even if a allowlist RegExp matches).\r\n   * @param {Array<RegExp>} [options.allowlist=[/./]] If any of these patterns\r\n   * match the URL's pathname and search parameter, the route will handle the\r\n   * request (assuming the denylist doesn't match).\r\n   */\n  function NavigationRoute(handler) {\n    var _this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$allowlist = _ref.allowlist,\n        allowlist = _ref$allowlist === void 0 ? [/./] : _ref$allowlist,\n        _ref$denylist = _ref.denylist,\n        denylist = _ref$denylist === void 0 ? [] : _ref$denylist;\n\n    _classCallCheck(this, NavigationRoute);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isArrayOfClass(allowlist, RegExp, {\n        moduleName: 'workbox-routing',\n        className: 'NavigationRoute',\n        funcName: 'constructor',\n        paramName: 'options.allowlist'\n      });\n      assert.isArrayOfClass(denylist, RegExp, {\n        moduleName: 'workbox-routing',\n        className: 'NavigationRoute',\n        funcName: 'constructor',\n        paramName: 'options.denylist'\n      });\n    }\n\n    _this = _super.call(this, function (options) {\n      return _this._match(options);\n    }, handler);\n    _this._allowlist = allowlist;\n    _this._denylist = denylist;\n    return _this;\n  }\n  /**\r\n   * Routes match handler.\r\n   *\r\n   * @param {Object} options\r\n   * @param {URL} options.url\r\n   * @param {Request} options.request\r\n   * @return {boolean}\r\n   *\r\n   * @private\r\n   */\n\n\n  _createClass(NavigationRoute, [{\n    key: \"_match\",\n    value: function _match(_ref2) {\n      var url = _ref2.url,\n          request = _ref2.request;\n\n      if (request && request.mode !== 'navigate') {\n        return false;\n      }\n\n      var pathnameAndSearch = url.pathname + url.search;\n\n      var _iterator = _createForOfIteratorHelper(this._denylist),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var regExp = _step.value;\n\n          if (regExp.test(pathnameAndSearch)) {\n            if (process.env.NODE_ENV !== 'production') {\n              logger.log(\"The navigation route \".concat(pathnameAndSearch, \" is not \") + \"being used, since the URL matches this denylist pattern: \" + \"\".concat(regExp));\n            }\n\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (this._allowlist.some(function (regExp) {\n        return regExp.test(pathnameAndSearch);\n      })) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(\"The navigation route \".concat(pathnameAndSearch, \" \") + \"is being used.\");\n        }\n\n        return true;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(\"The navigation route \".concat(pathnameAndSearch, \" is not \") + \"being used, since the URL being navigated to doesn't \" + \"match the allowlist.\");\n      }\n\n      return false;\n    }\n  }]);\n\n  return NavigationRoute;\n}(Route);\n\nexport { NavigationRoute };","map":{"version":3,"sources":["C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/workbox-routing/NavigationRoute.js"],"names":["assert","logger","Route","NavigationRoute","handler","allowlist","denylist","process","env","NODE_ENV","isArrayOfClass","RegExp","moduleName","className","funcName","paramName","options","_match","_allowlist","_denylist","url","request","mode","pathnameAndSearch","pathname","search","regExp","test","log","some","debug"],"mappings":"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","sourcesContent":["/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { assert } from 'workbox-core/_private/assert.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { Route } from './Route.js';\r\nimport './_version.js';\r\n/**\r\n * NavigationRoute makes it easy to create a\r\n * [Route]{@link module:workbox-routing.Route} that matches for browser\r\n * [navigation requests]{@link https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading#first_what_are_navigation_requests}.\r\n *\r\n * It will only match incoming Requests whose\r\n * [`mode`]{@link https://fetch.spec.whatwg.org/#concept-request-mode}\r\n * is set to `navigate`.\r\n *\r\n * You can optionally only apply this route to a subset of navigation requests\r\n * by using one or both of the `denylist` and `allowlist` parameters.\r\n *\r\n * @memberof module:workbox-routing\r\n * @extends module:workbox-routing.Route\r\n */\r\nclass NavigationRoute extends Route {\r\n    /**\r\n     * If both `denylist` and `allowlist` are provided, the `denylist` will\r\n     * take precedence and the request will not match this route.\r\n     *\r\n     * The regular expressions in `allowlist` and `denylist`\r\n     * are matched against the concatenated\r\n     * [`pathname`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname}\r\n     * and [`search`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search}\r\n     * portions of the requested URL.\r\n     *\r\n     * @param {module:workbox-routing~handlerCallback} handler A callback\r\n     * function that returns a Promise resulting in a Response.\r\n     * @param {Object} options\r\n     * @param {Array<RegExp>} [options.denylist] If any of these patterns match,\r\n     * the route will not handle the request (even if a allowlist RegExp matches).\r\n     * @param {Array<RegExp>} [options.allowlist=[/./]] If any of these patterns\r\n     * match the URL's pathname and search parameter, the route will handle the\r\n     * request (assuming the denylist doesn't match).\r\n     */\r\n    constructor(handler, { allowlist = [/./], denylist = [] } = {}) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isArrayOfClass(allowlist, RegExp, {\r\n                moduleName: 'workbox-routing',\r\n                className: 'NavigationRoute',\r\n                funcName: 'constructor',\r\n                paramName: 'options.allowlist',\r\n            });\r\n            assert.isArrayOfClass(denylist, RegExp, {\r\n                moduleName: 'workbox-routing',\r\n                className: 'NavigationRoute',\r\n                funcName: 'constructor',\r\n                paramName: 'options.denylist',\r\n            });\r\n        }\r\n        super((options) => this._match(options), handler);\r\n        this._allowlist = allowlist;\r\n        this._denylist = denylist;\r\n    }\r\n    /**\r\n     * Routes match handler.\r\n     *\r\n     * @param {Object} options\r\n     * @param {URL} options.url\r\n     * @param {Request} options.request\r\n     * @return {boolean}\r\n     *\r\n     * @private\r\n     */\r\n    _match({ url, request }) {\r\n        if (request && request.mode !== 'navigate') {\r\n            return false;\r\n        }\r\n        const pathnameAndSearch = url.pathname + url.search;\r\n        for (const regExp of this._denylist) {\r\n            if (regExp.test(pathnameAndSearch)) {\r\n                if (process.env.NODE_ENV !== 'production') {\r\n                    logger.log(`The navigation route ${pathnameAndSearch} is not ` +\r\n                        `being used, since the URL matches this denylist pattern: ` +\r\n                        `${regExp}`);\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n        if (this._allowlist.some((regExp) => regExp.test(pathnameAndSearch))) {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                logger.debug(`The navigation route ${pathnameAndSearch} ` +\r\n                    `is being used.`);\r\n            }\r\n            return true;\r\n        }\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            logger.log(`The navigation route ${pathnameAndSearch} is not ` +\r\n                `being used, since the URL being navigated to doesn't ` +\r\n                `match the allowlist.`);\r\n        }\r\n        return false;\r\n    }\r\n}\r\nexport { NavigationRoute };\r\n"]},"metadata":{},"sourceType":"module"}