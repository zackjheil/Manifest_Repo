{"ast":null,"code":"import logger from '../../utils/logger';\nimport isSubset from '../../utils/isSubset';\nimport updateObject from '../../utils/updateObject';\nimport success from '../../api-utils/success';\nimport error from '../../api-utils/error';\nimport showUserErrors from '../../api-utils/showUserErrors';\nexport default function update(docUpdates) {\n  let collectionName = this.collectionName;\n  let docSelectionCriteria = this.docSelectionCriteria;\n  return new Promise((resolve, reject) => {\n    // update document by criteria\n    this.updateDocumentByCriteria = () => {\n      let docsToUpdate = [];\n      this.lf[collectionName].iterate((value, key) => {\n        if (isSubset(value, docSelectionCriteria)) {\n          let newDocument = updateObject(value, docUpdates);\n          docsToUpdate.push({\n            key,\n            newDocument\n          });\n        }\n      }).then(() => {\n        if (!docsToUpdate.length) {\n          reject(error.call(this, `No Documents found in ${collectionName} Collection with criteria ${JSON.stringify(docSelectionCriteria)}.`));\n        }\n\n        if (docsToUpdate.length > 1) {\n          logger.warn.call(this, `Multiple documents (${docsToUpdate.length}) with ${JSON.stringify(docSelectionCriteria)} found for updating.`);\n        }\n      }).then(() => {\n        docsToUpdate.forEach((docToUpdate, index) => {\n          this.lf[collectionName].setItem(docToUpdate.key, docToUpdate.newDocument).then(value => {\n            if (index === docsToUpdate.length - 1) {\n              resolve(success.call(this, `${docsToUpdate.length} Document${docsToUpdate.length > 1 ? 's' : ''} in \"${collectionName}\" collection with ${JSON.stringify(docSelectionCriteria)} updated with:`, docUpdates));\n            }\n          }).catch(err => {\n            reject(error.call(this, `Could not update ${docsToUpdate.length} Documents in ${collectionName} Collection.`));\n          });\n        });\n      });\n    }; // update document by key\n\n\n    this.updateDocumentByKey = () => {\n      let newDocument = {};\n      this.lf[collectionName].getItem(docSelectionCriteria).then(value => {\n        newDocument = updateObject(value, docUpdates);\n        this.lf[collectionName].setItem(docSelectionCriteria, newDocument);\n        resolve(success.call(this, `Document in \"${collectionName}\" collection with key ${JSON.stringify(docSelectionCriteria)} updated to:`, newDocument));\n      }).catch(err => {\n        reject(error.call(this, `No Document found in \"${collectionName}\" collection with key ${JSON.stringify(docSelectionCriteria)}`));\n      });\n    }; // check for user errors\n\n\n    if (!docUpdates) {\n      this.userErrors.push('No update object provided to update() method. Use an object e.g. { name: \"William\" }');\n    } else if (!(typeof docUpdates == 'object' && docUpdates instanceof Array == false)) {\n      this.userErrors.push('Data passed to .update() must be an object. Not an array, string, number or boolean.');\n    }\n\n    if (!this.userErrors.length) {\n      if (typeof docSelectionCriteria == 'object') {\n        this.updateDocumentByCriteria();\n      } else {\n        this.updateDocumentByKey();\n      }\n    } else {\n      showUserErrors.call(this);\n    }\n  });\n}","map":{"version":3,"sources":["/Users/jemvandeworp/Documents/GitHub/Manifest_Repo/node_modules/localbase/localbase/api/actions/update.js"],"names":["logger","isSubset","updateObject","success","error","showUserErrors","update","docUpdates","collectionName","docSelectionCriteria","Promise","resolve","reject","updateDocumentByCriteria","docsToUpdate","lf","iterate","value","key","newDocument","push","then","length","call","JSON","stringify","warn","forEach","docToUpdate","index","setItem","catch","err","updateDocumentByKey","getItem","userErrors","Array"],"mappings":"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","sourcesContent":["import logger from '../../utils/logger'\nimport isSubset from '../../utils/isSubset'\nimport updateObject from '../../utils/updateObject'\nimport success from '../../api-utils/success'\nimport error from '../../api-utils/error'\nimport showUserErrors from '../../api-utils/showUserErrors'\n\nexport default function update(docUpdates) {\n  let collectionName = this.collectionName\n  let docSelectionCriteria = this.docSelectionCriteria\n\n  return new Promise((resolve, reject) => {\n\n    // update document by criteria\n    this.updateDocumentByCriteria = () => {\n      let docsToUpdate = []\n      this.lf[collectionName].iterate((value, key) => {\n        if (isSubset(value, docSelectionCriteria)) {\n          let newDocument = updateObject(value, docUpdates)\n          docsToUpdate.push({ key, newDocument })\n        }\n      }).then(() => {\n        if (!docsToUpdate.length) {\n          reject(\n            error.call(\n              this,\n              `No Documents found in ${ collectionName } Collection with criteria ${ JSON.stringify(docSelectionCriteria) }.`\n            )\n          )\n        }\n        if (docsToUpdate.length > 1) {\n          logger.warn.call(this, `Multiple documents (${ docsToUpdate.length }) with ${ JSON.stringify(docSelectionCriteria) } found for updating.`)\n        }\n      }).then(() => {\n        docsToUpdate.forEach((docToUpdate, index) => {\n          this.lf[collectionName].setItem(docToUpdate.key, docToUpdate.newDocument).then(value => {\n\n            if (index === (docsToUpdate.length - 1)) {\n              resolve(\n                success.call(\n                  this,\n                  `${ docsToUpdate.length } Document${ docsToUpdate.length > 1 ? 's' : '' } in \"${ collectionName }\" collection with ${ JSON.stringify(docSelectionCriteria) } updated with:`,\n                  docUpdates\n                )\n              )\n            }\n\n          }).catch(err => {\n            reject(\n              error.call(\n                this,\n                `Could not update ${ docsToUpdate.length } Documents in ${ collectionName } Collection.`\n              )\n            )\n          })\n        })\n      })\n    }\n  \n    // update document by key\n    this.updateDocumentByKey = () => {\n      let newDocument = {}\n      this.lf[collectionName].getItem(docSelectionCriteria).then(value => {\n        newDocument = updateObject(value, docUpdates)\n        this.lf[collectionName].setItem(docSelectionCriteria, newDocument)\n        resolve(\n          success.call(\n            this,\n            `Document in \"${ collectionName }\" collection with key ${ JSON.stringify(docSelectionCriteria) } updated to:`,\n            newDocument\n          )\n        )\n      }).catch(err => {\n        reject(\n          error.call(\n            this,\n            `No Document found in \"${ collectionName }\" collection with key ${ JSON.stringify(docSelectionCriteria) }`\n          )\n        )\n      })\n    }\n\n    // check for user errors\n    if (!docUpdates) {\n      this.userErrors.push('No update object provided to update() method. Use an object e.g. { name: \"William\" }')\n    }\n    else if (!(typeof docUpdates == 'object' && docUpdates instanceof Array == false)) {\n      this.userErrors.push('Data passed to .update() must be an object. Not an array, string, number or boolean.')\n    }\n\n    if (!this.userErrors.length) {\n      if (typeof docSelectionCriteria == 'object') {\n        this.updateDocumentByCriteria()\n      }\n      else {\n        this.updateDocumentByKey()\n      }\n    }\n    else {\n      showUserErrors.call(this)\n    }\n\n  })\n\n}"]},"metadata":{},"sourceType":"module"}