{"ast":null,"code":"/*\r\n  Copyright 2019 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Route } from './Route.js';\nimport { RegExpRoute } from './RegExpRoute.js';\nimport { getOrCreateDefaultRouter } from './utils/getOrCreateDefaultRouter.js';\nimport './_version.js';\n/**\r\n * Easily register a RegExp, string, or function with a caching\r\n * strategy to a singleton Router instance.\r\n *\r\n * This method will generate a Route for you if needed and\r\n * call [registerRoute()]{@link module:workbox-routing.Router#registerRoute}.\r\n *\r\n * @param {RegExp|string|module:workbox-routing.Route~matchCallback|module:workbox-routing.Route} capture\r\n * If the capture param is a `Route`, all other arguments will be ignored.\r\n * @param {module:workbox-routing~handlerCallback} [handler] A callback\r\n * function that returns a Promise resulting in a Response. This parameter\r\n * is required if `capture` is not a `Route` object.\r\n * @param {string} [method='GET'] The HTTP method to match the Route\r\n * against.\r\n * @return {module:workbox-routing.Route} The generated `Route`(Useful for\r\n * unregistering).\r\n *\r\n * @memberof module:workbox-routing\r\n */\n\nfunction registerRoute(capture, handler, method) {\n  var route;\n\n  if (typeof capture === 'string') {\n    var captureUrl = new URL(capture, location.href);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n        throw new WorkboxError('invalid-string', {\n          moduleName: 'workbox-routing',\n          funcName: 'registerRoute',\n          paramName: 'capture'\n        });\n      } // We want to check if Express-style wildcards are in the pathname only.\n      // TODO: Remove this log message in v4.\n\n\n      var valueToCheck = capture.startsWith('http') ? captureUrl.pathname : capture; // See https://github.com/pillarjs/path-to-regexp#parameters\n\n      var wildcards = '[*:?+]';\n\n      if (new RegExp(\"\".concat(wildcards)).exec(valueToCheck)) {\n        logger.debug(\"The '$capture' parameter contains an Express-style wildcard \" + \"character (\".concat(wildcards, \"). Strings are now always interpreted as \") + \"exact matches; use a RegExp for partial or wildcard matches.\");\n      }\n    }\n\n    var matchCallback = function matchCallback(_ref) {\n      var url = _ref.url;\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (url.pathname === captureUrl.pathname && url.origin !== captureUrl.origin) {\n          logger.debug(\"\".concat(capture, \" only partially matches the cross-origin URL \") + \"\".concat(url, \". This route will only handle cross-origin requests \") + \"if they match the entire URL.\");\n        }\n      }\n\n      return url.href === captureUrl.href;\n    }; // If `capture` is a string then `handler` and `method` must be present.\n\n\n    route = new Route(matchCallback, handler, method);\n  } else if (capture instanceof RegExp) {\n    // If `capture` is a `RegExp` then `handler` and `method` must be present.\n    route = new RegExpRoute(capture, handler, method);\n  } else if (typeof capture === 'function') {\n    // If `capture` is a function then `handler` and `method` must be present.\n    route = new Route(capture, handler, method);\n  } else if (capture instanceof Route) {\n    route = capture;\n  } else {\n    throw new WorkboxError('unsupported-route-type', {\n      moduleName: 'workbox-routing',\n      funcName: 'registerRoute',\n      paramName: 'capture'\n    });\n  }\n\n  var defaultRouter = getOrCreateDefaultRouter();\n  defaultRouter.registerRoute(route);\n  return route;\n}\n\nexport { registerRoute };","map":{"version":3,"sources":["C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/workbox-routing/registerRoute.js"],"names":["logger","WorkboxError","Route","RegExpRoute","getOrCreateDefaultRouter","registerRoute","capture","handler","method","route","captureUrl","URL","location","href","process","env","NODE_ENV","startsWith","moduleName","funcName","paramName","valueToCheck","pathname","wildcards","RegExp","exec","debug","matchCallback","url","origin","defaultRouter"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAT,QAAuB,iCAAvB;AACA,SAASC,YAAT,QAA6B,uCAA7B;AACA,SAASC,KAAT,QAAsB,YAAtB;AACA,SAASC,WAAT,QAA4B,kBAA5B;AACA,SAASC,wBAAT,QAAyC,qCAAzC;AACA,OAAO,eAAP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,aAAT,CAAuBC,OAAvB,EAAgCC,OAAhC,EAAyCC,MAAzC,EAAiD;AAC7C,MAAIC,KAAJ;;AACA,MAAI,OAAOH,OAAP,KAAmB,QAAvB,EAAiC;AAC7B,QAAMI,UAAU,GAAG,IAAIC,GAAJ,CAAQL,OAAR,EAAiBM,QAAQ,CAACC,IAA1B,CAAnB;;AACA,QAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACvC,UAAI,EAAEV,OAAO,CAACW,UAAR,CAAmB,GAAnB,KAA2BX,OAAO,CAACW,UAAR,CAAmB,MAAnB,CAA7B,CAAJ,EAA8D;AAC1D,cAAM,IAAIhB,YAAJ,CAAiB,gBAAjB,EAAmC;AACrCiB,UAAAA,UAAU,EAAE,iBADyB;AAErCC,UAAAA,QAAQ,EAAE,eAF2B;AAGrCC,UAAAA,SAAS,EAAE;AAH0B,SAAnC,CAAN;AAKH,OAPsC,CAQvC;AACA;;;AACA,UAAMC,YAAY,GAAGf,OAAO,CAACW,UAAR,CAAmB,MAAnB,IACjBP,UAAU,CAACY,QADM,GACKhB,OAD1B,CAVuC,CAYvC;;AACA,UAAMiB,SAAS,GAAG,QAAlB;;AACA,UAAK,IAAIC,MAAJ,WAAcD,SAAd,EAAD,CAA6BE,IAA7B,CAAkCJ,YAAlC,CAAJ,EAAqD;AACjDrB,QAAAA,MAAM,CAAC0B,KAAP,CAAa,sFACKH,SADL,+GAAb;AAGH;AACJ;;AACD,QAAMI,aAAa,GAAG,SAAhBA,aAAgB,OAAa;AAAA,UAAVC,GAAU,QAAVA,GAAU;;AAC/B,UAAId,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACvC,YAAKY,GAAG,CAACN,QAAJ,KAAiBZ,UAAU,CAACY,QAA7B,IACCM,GAAG,CAACC,MAAJ,KAAenB,UAAU,CAACmB,MAD/B,EACwC;AACpC7B,UAAAA,MAAM,CAAC0B,KAAP,CAAa,UAAGpB,OAAH,+DACNsB,GADM,2FAAb;AAGH;AACJ;;AACD,aAAOA,GAAG,CAACf,IAAJ,KAAaH,UAAU,CAACG,IAA/B;AACH,KAVD,CAtB6B,CAiC7B;;;AACAJ,IAAAA,KAAK,GAAG,IAAIP,KAAJ,CAAUyB,aAAV,EAAyBpB,OAAzB,EAAkCC,MAAlC,CAAR;AACH,GAnCD,MAoCK,IAAIF,OAAO,YAAYkB,MAAvB,EAA+B;AAChC;AACAf,IAAAA,KAAK,GAAG,IAAIN,WAAJ,CAAgBG,OAAhB,EAAyBC,OAAzB,EAAkCC,MAAlC,CAAR;AACH,GAHI,MAIA,IAAI,OAAOF,OAAP,KAAmB,UAAvB,EAAmC;AACpC;AACAG,IAAAA,KAAK,GAAG,IAAIP,KAAJ,CAAUI,OAAV,EAAmBC,OAAnB,EAA4BC,MAA5B,CAAR;AACH,GAHI,MAIA,IAAIF,OAAO,YAAYJ,KAAvB,EAA8B;AAC/BO,IAAAA,KAAK,GAAGH,OAAR;AACH,GAFI,MAGA;AACD,UAAM,IAAIL,YAAJ,CAAiB,wBAAjB,EAA2C;AAC7CiB,MAAAA,UAAU,EAAE,iBADiC;AAE7CC,MAAAA,QAAQ,EAAE,eAFmC;AAG7CC,MAAAA,SAAS,EAAE;AAHkC,KAA3C,CAAN;AAKH;;AACD,MAAMU,aAAa,GAAG1B,wBAAwB,EAA9C;AACA0B,EAAAA,aAAa,CAACzB,aAAd,CAA4BI,KAA5B;AACA,SAAOA,KAAP;AACH;;AACD,SAASJ,aAAT","sourcesContent":["/*\r\n  Copyright 2019 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport { Route } from './Route.js';\r\nimport { RegExpRoute } from './RegExpRoute.js';\r\nimport { getOrCreateDefaultRouter } from './utils/getOrCreateDefaultRouter.js';\r\nimport './_version.js';\r\n/**\r\n * Easily register a RegExp, string, or function with a caching\r\n * strategy to a singleton Router instance.\r\n *\r\n * This method will generate a Route for you if needed and\r\n * call [registerRoute()]{@link module:workbox-routing.Router#registerRoute}.\r\n *\r\n * @param {RegExp|string|module:workbox-routing.Route~matchCallback|module:workbox-routing.Route} capture\r\n * If the capture param is a `Route`, all other arguments will be ignored.\r\n * @param {module:workbox-routing~handlerCallback} [handler] A callback\r\n * function that returns a Promise resulting in a Response. This parameter\r\n * is required if `capture` is not a `Route` object.\r\n * @param {string} [method='GET'] The HTTP method to match the Route\r\n * against.\r\n * @return {module:workbox-routing.Route} The generated `Route`(Useful for\r\n * unregistering).\r\n *\r\n * @memberof module:workbox-routing\r\n */\r\nfunction registerRoute(capture, handler, method) {\r\n    let route;\r\n    if (typeof capture === 'string') {\r\n        const captureUrl = new URL(capture, location.href);\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!(capture.startsWith('/') || capture.startsWith('http'))) {\r\n                throw new WorkboxError('invalid-string', {\r\n                    moduleName: 'workbox-routing',\r\n                    funcName: 'registerRoute',\r\n                    paramName: 'capture',\r\n                });\r\n            }\r\n            // We want to check if Express-style wildcards are in the pathname only.\r\n            // TODO: Remove this log message in v4.\r\n            const valueToCheck = capture.startsWith('http') ?\r\n                captureUrl.pathname : capture;\r\n            // See https://github.com/pillarjs/path-to-regexp#parameters\r\n            const wildcards = '[*:?+]';\r\n            if ((new RegExp(`${wildcards}`)).exec(valueToCheck)) {\r\n                logger.debug(`The '$capture' parameter contains an Express-style wildcard ` +\r\n                    `character (${wildcards}). Strings are now always interpreted as ` +\r\n                    `exact matches; use a RegExp for partial or wildcard matches.`);\r\n            }\r\n        }\r\n        const matchCallback = ({ url }) => {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                if ((url.pathname === captureUrl.pathname) &&\r\n                    (url.origin !== captureUrl.origin)) {\r\n                    logger.debug(`${capture} only partially matches the cross-origin URL ` +\r\n                        `${url}. This route will only handle cross-origin requests ` +\r\n                        `if they match the entire URL.`);\r\n                }\r\n            }\r\n            return url.href === captureUrl.href;\r\n        };\r\n        // If `capture` is a string then `handler` and `method` must be present.\r\n        route = new Route(matchCallback, handler, method);\r\n    }\r\n    else if (capture instanceof RegExp) {\r\n        // If `capture` is a `RegExp` then `handler` and `method` must be present.\r\n        route = new RegExpRoute(capture, handler, method);\r\n    }\r\n    else if (typeof capture === 'function') {\r\n        // If `capture` is a function then `handler` and `method` must be present.\r\n        route = new Route(capture, handler, method);\r\n    }\r\n    else if (capture instanceof Route) {\r\n        route = capture;\r\n    }\r\n    else {\r\n        throw new WorkboxError('unsupported-route-type', {\r\n            moduleName: 'workbox-routing',\r\n            funcName: 'registerRoute',\r\n            paramName: 'capture',\r\n        });\r\n    }\r\n    const defaultRouter = getOrCreateDefaultRouter();\r\n    defaultRouter.registerRoute(route);\r\n    return route;\r\n}\r\nexport { registerRoute };\r\n"]},"metadata":{},"sourceType":"module"}