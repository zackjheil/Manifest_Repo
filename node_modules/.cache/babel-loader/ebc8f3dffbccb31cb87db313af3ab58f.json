{"ast":null,"code":"/*\r\n  Copyright 2019 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getCacheKeyForURL } from './getCacheKeyForURL.js';\nimport '../_version.js';\n/**\r\n * Adds a `fetch` listener to the service worker that will\r\n * respond to\r\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\r\n * with precached assets.\r\n *\r\n * Requests for assets that aren't precached, the `FetchEvent` will not be\r\n * responded to, allowing the event to fall through to other `fetch` event\r\n * listeners.\r\n *\r\n * NOTE: when called more than once this method will replace the previously set\r\n * configuration options. Calling it more than once is not recommended outside\r\n * of tests.\r\n *\r\n * @private\r\n * @param {Object} [options]\r\n * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\r\n * check cache entries for a URLs ending with '/' to see if there is a hit when\r\n * appending the `directoryIndex` value.\r\n * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\r\n * array of regex's to remove search params when looking for a cache match.\r\n * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\r\n * check the cache for the URL with a `.html` added to the end of the end.\r\n * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\r\n * This is a function that should take a URL and return an array of\r\n * alternative URLs that should be checked for precache matches.\r\n */\n\nexport var addFetchListener = function addFetchListener() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$ignoreURLParamet = _ref.ignoreURLParametersMatching,\n      ignoreURLParametersMatching = _ref$ignoreURLParamet === void 0 ? [/^utm_/] : _ref$ignoreURLParamet,\n      _ref$directoryIndex = _ref.directoryIndex,\n      directoryIndex = _ref$directoryIndex === void 0 ? 'index.html' : _ref$directoryIndex,\n      _ref$cleanURLs = _ref.cleanURLs,\n      cleanURLs = _ref$cleanURLs === void 0 ? true : _ref$cleanURLs,\n      urlManipulation = _ref.urlManipulation;\n\n  var cacheName = cacheNames.getPrecacheName(); // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n\n  self.addEventListener('fetch', function (event) {\n    var precachedURL = getCacheKeyForURL(event.request.url, {\n      cleanURLs: cleanURLs,\n      directoryIndex: directoryIndex,\n      ignoreURLParametersMatching: ignoreURLParametersMatching,\n      urlManipulation: urlManipulation\n    });\n\n    if (!precachedURL) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(\"Precaching did not find a match for \" + getFriendlyURL(event.request.url));\n      }\n\n      return;\n    }\n\n    var responsePromise = self.caches.open(cacheName).then(function (cache) {\n      return cache.match(precachedURL);\n    }).then(function (cachedResponse) {\n      if (cachedResponse) {\n        return cachedResponse;\n      } // Fall back to the network if we don't have a cached response\n      // (perhaps due to manual cache cleanup).\n\n\n      if (process.env.NODE_ENV !== 'production') {\n        logger.warn(\"The precached response for \" + \"\".concat(getFriendlyURL(precachedURL), \" in \").concat(cacheName, \" was not found. \") + \"Falling back to the network instead.\");\n      }\n\n      return fetch(precachedURL);\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      responsePromise = responsePromise.then(function (response) {\n        // Workbox is going to handle the route.\n        // print the routing details to the console.\n        logger.groupCollapsed(\"Precaching is responding to: \" + getFriendlyURL(event.request.url));\n        logger.log(\"Serving the precached url: \".concat(precachedURL));\n        logger.groupCollapsed(\"View request details here.\");\n        logger.log(event.request);\n        logger.groupEnd();\n        logger.groupCollapsed(\"View response details here.\");\n        logger.log(response);\n        logger.groupEnd();\n        logger.groupEnd();\n        return response;\n      });\n    }\n\n    event.respondWith(responsePromise);\n  });\n};","map":{"version":3,"sources":["C:/Users/zackj/Documents/GitHub/Manifest_Repo/node_modules/workbox-precaching/utils/addFetchListener.js"],"names":["cacheNames","getFriendlyURL","logger","getCacheKeyForURL","addFetchListener","ignoreURLParametersMatching","directoryIndex","cleanURLs","urlManipulation","cacheName","getPrecacheName","self","addEventListener","event","precachedURL","request","url","process","env","NODE_ENV","debug","responsePromise","caches","open","then","cache","match","cachedResponse","warn","fetch","response","groupCollapsed","log","groupEnd","respondWith"],"mappings":"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","sourcesContent":["/*\r\n  Copyright 2019 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\r\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { getCacheKeyForURL } from './getCacheKeyForURL.js';\r\nimport '../_version.js';\r\n/**\r\n * Adds a `fetch` listener to the service worker that will\r\n * respond to\r\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\r\n * with precached assets.\r\n *\r\n * Requests for assets that aren't precached, the `FetchEvent` will not be\r\n * responded to, allowing the event to fall through to other `fetch` event\r\n * listeners.\r\n *\r\n * NOTE: when called more than once this method will replace the previously set\r\n * configuration options. Calling it more than once is not recommended outside\r\n * of tests.\r\n *\r\n * @private\r\n * @param {Object} [options]\r\n * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\r\n * check cache entries for a URLs ending with '/' to see if there is a hit when\r\n * appending the `directoryIndex` value.\r\n * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\r\n * array of regex's to remove search params when looking for a cache match.\r\n * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\r\n * check the cache for the URL with a `.html` added to the end of the end.\r\n * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\r\n * This is a function that should take a URL and return an array of\r\n * alternative URLs that should be checked for precache matches.\r\n */\r\nexport const addFetchListener = ({ ignoreURLParametersMatching = [/^utm_/], directoryIndex = 'index.html', cleanURLs = true, urlManipulation, } = {}) => {\r\n    const cacheName = cacheNames.getPrecacheName();\r\n    // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\r\n    self.addEventListener('fetch', ((event) => {\r\n        const precachedURL = getCacheKeyForURL(event.request.url, {\r\n            cleanURLs,\r\n            directoryIndex,\r\n            ignoreURLParametersMatching,\r\n            urlManipulation,\r\n        });\r\n        if (!precachedURL) {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                logger.debug(`Precaching did not find a match for ` +\r\n                    getFriendlyURL(event.request.url));\r\n            }\r\n            return;\r\n        }\r\n        let responsePromise = self.caches.open(cacheName).then((cache) => {\r\n            return cache.match(precachedURL);\r\n        }).then((cachedResponse) => {\r\n            if (cachedResponse) {\r\n                return cachedResponse;\r\n            }\r\n            // Fall back to the network if we don't have a cached response\r\n            // (perhaps due to manual cache cleanup).\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                logger.warn(`The precached response for ` +\r\n                    `${getFriendlyURL(precachedURL)} in ${cacheName} was not found. ` +\r\n                    `Falling back to the network instead.`);\r\n            }\r\n            return fetch(precachedURL);\r\n        });\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            responsePromise = responsePromise.then((response) => {\r\n                // Workbox is going to handle the route.\r\n                // print the routing details to the console.\r\n                logger.groupCollapsed(`Precaching is responding to: ` +\r\n                    getFriendlyURL(event.request.url));\r\n                logger.log(`Serving the precached url: ${precachedURL}`);\r\n                logger.groupCollapsed(`View request details here.`);\r\n                logger.log(event.request);\r\n                logger.groupEnd();\r\n                logger.groupCollapsed(`View response details here.`);\r\n                logger.log(response);\r\n                logger.groupEnd();\r\n                logger.groupEnd();\r\n                return response;\r\n            });\r\n        }\r\n        event.respondWith(responsePromise);\r\n    }));\r\n};\r\n"]},"metadata":{},"sourceType":"module"}